/* automatically generated by rust-bindgen 0.59.1 */

pub const K4A_TRACK_NAME_COLOR: &'static [u8; 6usize] = b"COLOR\0";
pub const K4A_TRACK_NAME_DEPTH: &'static [u8; 6usize] = b"DEPTH\0";
pub const K4A_TRACK_NAME_IR: &'static [u8; 3usize] = b"IR\0";
pub const K4A_TRACK_NAME_IMU: &'static [u8; 4usize] = b"IMU\0";
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_device_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_device_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_device_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_device_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_device_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_device_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_device_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_device_t = *mut _k4a_device_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_capture_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_capture_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_capture_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_capture_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_capture_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_capture_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_capture_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_capture_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_capture_t = *mut _k4a_capture_t;
#[doc = "< The result was successful"]
pub const k4a_result_t_K4A_RESULT_SUCCEEDED: k4a_result_t = 0;
#[doc = "< The result was a failure"]
pub const k4a_result_t_K4A_RESULT_FAILED: k4a_result_t = 1;
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_result_t = ::std::os::raw::c_uint;
#[doc = "< The result was successful"]
pub const k4a_buffer_result_t_K4A_BUFFER_RESULT_SUCCEEDED: k4a_buffer_result_t = 0;
#[doc = "< The result was a failure"]
pub const k4a_buffer_result_t_K4A_BUFFER_RESULT_FAILED: k4a_buffer_result_t = 1;
#[doc = "< The input buffer was too small"]
pub const k4a_buffer_result_t_K4A_BUFFER_RESULT_TOO_SMALL: k4a_buffer_result_t = 2;
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_buffer_result_t = ::std::os::raw::c_uint;
#[doc = "< Depth sensor will be turned off with this setting."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_OFF: k4a_depth_mode_t = 0;
#[doc = "< Depth captured at 320x288. Passive IR is also captured at 320x288."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_NFOV_2X2BINNED: k4a_depth_mode_t = 1;
#[doc = "< Depth captured at 640x576. Passive IR is also captured at 640x576."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_NFOV_UNBINNED: k4a_depth_mode_t = 2;
#[doc = "< Depth captured at 512x512. Passive IR is also captured at 512x512."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_WFOV_2X2BINNED: k4a_depth_mode_t = 3;
#[doc = "< Depth captured at 1024x1024. Passive IR is also captured at 1024x1024."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_WFOV_UNBINNED: k4a_depth_mode_t = 4;
#[doc = "< Passive IR only, captured at 1024x1024."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_PASSIVE_IR: k4a_depth_mode_t = 5;
#[doc = " Depth sensor capture modes."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " See the hardware specification for additional details on the field of view, and supported frame rates"]
#[doc = " for each mode."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " NFOV and WFOV denote Narrow and Wide Field Of View configurations."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Binned modes reduce the captured camera resolution by combining adjacent sensor pixels into a bin."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_depth_mode_t = ::std::os::raw::c_uint;
#[doc = "< Color camera will be turned off with this setting"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_OFF: k4a_color_resolution_t = 0;
#[doc = "< 1280 * 720  16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_720P: k4a_color_resolution_t = 1;
#[doc = "< 1920 * 1080 16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_1080P: k4a_color_resolution_t = 2;
#[doc = "< 2560 * 1440 16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_1440P: k4a_color_resolution_t = 3;
#[doc = "< 2048 * 1536 4:3"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_1536P: k4a_color_resolution_t = 4;
#[doc = "< 3840 * 2160 16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_2160P: k4a_color_resolution_t = 5;
#[doc = "< 4096 * 3072 4:3"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_3072P: k4a_color_resolution_t = 6;
#[doc = " Color sensor resolutions."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_color_resolution_t = ::std::os::raw::c_uint;
#[doc = " Color image type MJPG."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The buffer for each image is encoded as a JPEG and can be decoded by a JPEG decoder."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Because the image is compressed, the stride parameter for the \\ref k4a_image_t is not applicable."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each MJPG encoded image in a stream may be of differing size depending on the compression efficiency."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_MJPG: k4a_image_format_t = 0;
#[doc = " Color image type NV12."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " NV12 images separate the luminance and chroma data such that all the luminance is at the"]
#[doc = " beginning of the buffer, and the chroma lines follow immediately after."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each line"]
#[doc = " of the image in memory. Chroma has half as many lines of height and half the width in pixels of the luminance."]
#[doc = " Each chroma line has the same width in bytes as a luminance line."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_NV12: k4a_image_format_t = 1;
#[doc = " Color image type YUY2."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " YUY2 stores chroma and luminance data in interleaved pixels."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_YUY2: k4a_image_format_t = 2;
#[doc = " Color image type BGRA32."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of BGRA32 data is four bytes. The first three bytes represent Blue, Green,"]
#[doc = " and Red data. The fourth byte is the alpha channel and is unused in the Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The Azure Kinect device does not natively capture in this format. Requesting images of this format"]
#[doc = " requires additional computation in the API."]
#[doc = ""]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_BGRA32: k4a_image_format_t = 3;
#[doc = " Depth image type DEPTH16."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of DEPTH16 data is two bytes of little endian unsigned depth data. The unit of the data is in"]
#[doc = " millimeters from the origin of the camera."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_DEPTH16: k4a_image_format_t = 4;
#[doc = " Image type IR16."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of IR16 data is two bytes of little endian unsigned depth data. The value of the data represents"]
#[doc = " brightness."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " This format represents infrared light and is captured by the depth camera."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_IR16: k4a_image_format_t = 5;
#[doc = " Single channel image type CUSTOM8."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of CUSTOM8 is a single channel one byte of unsigned data."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_CUSTOM8: k4a_image_format_t = 6;
#[doc = " Single channel image type CUSTOM16."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of CUSTOM16 is a single channel two bytes of little endian unsigned data."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_CUSTOM16: k4a_image_format_t = 7;
#[doc = " Custom image format."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Used in conjunction with user created images or images packing non-standard data."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " See the originator of the custom formatted image for information on how to interpret the data."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_CUSTOM: k4a_image_format_t = 8;
#[doc = " Image format type."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The image format indicates how the \\ref k4a_image_t buffer data is interpreted."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_image_format_t = ::std::os::raw::c_uint;
#[doc = "< 5 FPS"]
pub const k4a_fps_t_K4A_FRAMES_PER_SECOND_5: k4a_fps_t = 0;
#[doc = "< 15 FPS"]
pub const k4a_fps_t_K4A_FRAMES_PER_SECOND_15: k4a_fps_t = 1;
#[doc = "< 30 FPS"]
pub const k4a_fps_t_K4A_FRAMES_PER_SECOND_30: k4a_fps_t = 2;
#[doc = " Color and depth sensor frame rate."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This enumeration is used to select the desired frame rate to operate the cameras. The actual"]
#[doc = " frame rate may vary slightly due to dropped data, synchronization variation between devices,"]
#[doc = " clock accuracy, or if the camera exposure priority mode causes reduced frame rate."]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_fps_t = ::std::os::raw::c_uint;
#[doc = "< Neither 'Sync In' or 'Sync Out' connections are used."]
pub const k4a_wired_sync_mode_t_K4A_WIRED_SYNC_MODE_STANDALONE: k4a_wired_sync_mode_t = 0;
#[doc = "< The 'Sync Out' jack is enabled and synchronization data it driven out the"]
#[doc = "connected wire. While in master mode the color camera must be enabled as part of the"]
#[doc = "multi device sync signalling logic. Even if the color image is not needed, the color"]
#[doc = "camera must be running."]
pub const k4a_wired_sync_mode_t_K4A_WIRED_SYNC_MODE_MASTER: k4a_wired_sync_mode_t = 1;
#[doc = "< The 'Sync In' jack is used for synchronization and 'Sync Out' is driven for the"]
#[doc = "next device in the chain. 'Sync Out' is a mirror of 'Sync In' for this mode."]
pub const k4a_wired_sync_mode_t_K4A_WIRED_SYNC_MODE_SUBORDINATE: k4a_wired_sync_mode_t = 2;
#[doc = " Synchronization mode when connecting two or more devices together."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_wired_sync_mode_t = ::std::os::raw::c_uint;
#[doc = "< Calibration model is unknown"]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_UNKNOWN:
    k4a_calibration_model_type_t = 0;
#[doc = "< Deprecated (not supported). Calibration model is Theta (arctan)."]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_THETA:
    k4a_calibration_model_type_t = 1;
#[doc = "< Deprecated (not supported). Calibration model is"]
#[doc = "Polynomial 3K."]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_POLYNOMIAL_3K:
    k4a_calibration_model_type_t = 2;
#[doc = "< Deprecated (only supported early internal devices)."]
#[doc = "Calibration model is Rational 6KT."]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_RATIONAL_6KT:
    k4a_calibration_model_type_t = 3;
#[doc = "< Calibration model is Brown Conrady (compatible with"]
#[doc = " OpenCV)"]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_BROWN_CONRADY:
    k4a_calibration_model_type_t = 4;
#[doc = " Calibration model type."]
#[doc = ""]
#[doc = " The model used interpret the calibration parameters."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_model_type_t = ::std::os::raw::c_uint;
#[doc = " Configuration parameters for an Azure Kinect device."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4a_device_start_cameras() to specify the configuration of the data capture."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_device_configuration_t {
    #[doc = " Image format to capture with the color camera."]
    #[doc = ""]
    #[doc = " The color camera does not natively produce BGRA32 images."]
    #[doc = " Setting ::K4A_IMAGE_FORMAT_COLOR_BGRA32 for color_format will result in higher CPU utilization."]
    pub color_format: k4a_image_format_t,
    #[doc = " Image resolution to capture with the color camera."]
    pub color_resolution: k4a_color_resolution_t,
    #[doc = " Capture mode for the depth camera."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = " Desired frame rate for the color and depth camera."]
    pub camera_fps: k4a_fps_t,
    #[doc = " Only produce k4a_capture_t objects if they contain synchronized color and depth images."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " This setting controls the behavior in which images are dropped when images are produced faster than they can be"]
    #[doc = " read, or if there are errors in reading images from the device."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " If set to true, \\ref k4a_capture_t objects will only be produced with both color and depth images."]
    #[doc = " If set to false, \\ref k4a_capture_t objects may be produced only a single image when the corresponding image is"]
    #[doc = " dropped."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Setting this to false ensures that the caller receives all of the images received from the camera, regardless of"]
    #[doc = " whether the corresponding images expected in the capture are available."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " If either the color or depth camera are disabled, this setting has no effect."]
    pub synchronized_images_only: bool,
    #[doc = " Desired delay between the capture of the color image and the capture of the depth image."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " A negative value indicates that the depth image should be captured before the color image."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Any value between negative and positive one capture period is valid."]
    pub depth_delay_off_color_usec: i32,
    #[doc = " The external synchronization mode."]
    pub wired_sync_mode: k4a_wired_sync_mode_t,
    #[doc = " The external synchronization timing."]
    #[doc = ""]
    #[doc = " If this camera is a subordinate, this sets the capture delay between the color camera capture and the external"]
    #[doc = " input pulse. A setting of zero indicates that the master and subordinate color images should be aligned."]
    #[doc = ""]
    #[doc = " This setting does not effect the 'Sync out' connection."]
    #[doc = ""]
    #[doc = " This value must be positive and range from zero to one capture period."]
    #[doc = ""]
    #[doc = " If this is not a subordinate, then this value is ignored."]
    pub subordinate_delay_off_master_usec: u32,
    #[doc = " Streaming indicator automatically turns on when the color or depth camera's are in use."]
    #[doc = ""]
    #[doc = " This setting disables that behavior and keeps the LED in an off state."]
    pub disable_streaming_indicator: bool,
}
#[test]
fn bindgen_test_layout__k4a_device_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_device_configuration_t>(),
        36usize,
        concat!("Size of: ", stringify!(_k4a_device_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_device_configuration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_device_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).color_format as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).color_resolution as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(color_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).depth_mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).camera_fps as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(camera_fps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).synchronized_images_only
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(synchronized_images_only)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).depth_delay_off_color_usec
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(depth_delay_off_color_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).wired_sync_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(wired_sync_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>()))
                .subordinate_delay_off_master_usec as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(subordinate_delay_off_master_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).disable_streaming_indicator
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(disable_streaming_indicator)
        )
    );
}
impl Default for _k4a_device_configuration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Configuration parameters for an Azure Kinect device."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4a_device_start_cameras() to specify the configuration of the data capture."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_device_configuration_t = _k4a_device_configuration_t;
#[doc = " Extrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Extrinsic calibration defines the physical relationship between two separate devices."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_calibration_extrinsics_t {
    #[doc = "< 3x3 Rotation matrix stored in row major order"]
    pub rotation: [f32; 9usize],
    #[doc = "< Translation vector, x,y,z (in millimeters)"]
    pub translation: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__k4a_calibration_extrinsics_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_extrinsics_t>(),
        48usize,
        concat!("Size of: ", stringify!(_k4a_calibration_extrinsics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_extrinsics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_extrinsics_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_extrinsics_t>())).rotation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_extrinsics_t),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_extrinsics_t>())).translation as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_extrinsics_t),
            "::",
            stringify!(translation)
        )
    );
}
#[doc = " Extrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Extrinsic calibration defines the physical relationship between two separate devices."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_extrinsics_t = _k4a_calibration_extrinsics_t;
#[doc = " Camera intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_calibration_intrinsic_parameters_t {
    #[doc = "< Individual parameter representation of intrinsic model"]
    pub param: k4a_calibration_intrinsic_parameters_t__param,
    #[doc = "< Array representation of intrinsic model parameters"]
    pub v: [f32; 15usize],
}
#[doc = " individual parameter or array representation of intrinsic model."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct k4a_calibration_intrinsic_parameters_t__param {
    #[doc = "< Principal point in image, x"]
    pub cx: f32,
    #[doc = "< Principal point in image, y"]
    pub cy: f32,
    #[doc = "< Focal length x"]
    pub fx: f32,
    #[doc = "< Focal length y"]
    pub fy: f32,
    #[doc = "< k1 radial distortion coefficient"]
    pub k1: f32,
    #[doc = "< k2 radial distortion coefficient"]
    pub k2: f32,
    #[doc = "< k3 radial distortion coefficient"]
    pub k3: f32,
    #[doc = "< k4 radial distortion coefficient"]
    pub k4: f32,
    #[doc = "< k5 radial distortion coefficient"]
    pub k5: f32,
    #[doc = "< k6 radial distortion coefficient"]
    pub k6: f32,
    #[doc = "< Center of distortion in Z=1 plane, x (only used for Rational6KT)"]
    pub codx: f32,
    #[doc = "< Center of distortion in Z=1 plane, y (only used for Rational6KT)"]
    pub cody: f32,
    #[doc = "< Tangential distortion coefficient 2"]
    pub p2: f32,
    #[doc = "< Tangential distortion coefficient 1"]
    pub p1: f32,
    #[doc = "< Metric radius"]
    pub metric_radius: f32,
}
#[test]
fn bindgen_test_layout_k4a_calibration_intrinsic_parameters_t__param() {
    assert_eq!(
        ::std::mem::size_of::<k4a_calibration_intrinsic_parameters_t__param>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_calibration_intrinsic_parameters_t__param>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cy as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).fx as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).fy as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k1 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k2 as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k3 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k4 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k5 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k6 as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).codx
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(codx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cody
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).p2 as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(p2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).p1 as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(p1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).metric_radius
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(metric_radius)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_calibration_intrinsic_parameters_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_calibration_intrinsic_parameters_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(k4a_calibration_intrinsic_parameters_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_calibration_intrinsic_parameters_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(k4a_calibration_intrinsic_parameters_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t>())).param as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t>())).v as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t),
            "::",
            stringify!(v)
        )
    );
}
impl Default for k4a_calibration_intrinsic_parameters_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Camera sensor intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_intrinsics_t {
    #[doc = "< Type of calibration model used"]
    pub type_: k4a_calibration_model_type_t,
    #[doc = "< Number of valid entries in parameters"]
    pub parameter_count: ::std::os::raw::c_uint,
    #[doc = "< Calibration parameters"]
    pub parameters: k4a_calibration_intrinsic_parameters_t,
}
#[test]
fn bindgen_test_layout__k4a_calibration_intrinsics_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_intrinsics_t>(),
        68usize,
        concat!("Size of: ", stringify!(_k4a_calibration_intrinsics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_intrinsics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_intrinsics_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).parameter_count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(parameter_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).parameters as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(parameters)
        )
    );
}
impl Default for _k4a_calibration_intrinsics_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Camera sensor intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_intrinsics_t = _k4a_calibration_intrinsics_t;
#[doc = " Camera calibration contains intrinsic and extrinsic calibration information for a camera."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_camera_t {
    #[doc = "< Extrinsic calibration data."]
    pub extrinsics: k4a_calibration_extrinsics_t,
    #[doc = "< Intrinsic calibration data."]
    pub intrinsics: k4a_calibration_intrinsics_t,
    #[doc = "< Resolution width of the calibration sensor."]
    pub resolution_width: ::std::os::raw::c_int,
    #[doc = "< Resolution height of the calibration sensor."]
    pub resolution_height: ::std::os::raw::c_int,
    #[doc = "< Max FOV of the camera."]
    pub metric_radius: f32,
}
#[test]
fn bindgen_test_layout__k4a_calibration_camera_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_camera_t>(),
        128usize,
        concat!("Size of: ", stringify!(_k4a_calibration_camera_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_camera_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_camera_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).extrinsics as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(extrinsics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).intrinsics as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(intrinsics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).resolution_width as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(resolution_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).resolution_height as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(resolution_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).metric_radius as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(metric_radius)
        )
    );
}
impl Default for _k4a_calibration_camera_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Camera calibration contains intrinsic and extrinsic calibration information for a camera."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_camera_t = _k4a_calibration_camera_t;
#[doc = " Calibration type representing device calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_t {
    #[doc = "< Depth camera calibration."]
    pub depth_camera_calibration: k4a_calibration_camera_t,
    #[doc = "< Color camera calibration."]
    pub color_camera_calibration: k4a_calibration_camera_t,
    #[doc = " Extrinsic transformation parameters."]
    #[doc = ""]
    #[doc = " The extrinsic parameters allow 3D coordinate conversions between depth camera, color camera, the IMU's gyroscope"]
    #[doc = " and accelerometer. To transform from a source to a target 3D coordinate system, use the parameters stored"]
    #[doc = " under extrinsics[source][target]."]
    pub extrinsics: [[k4a_calibration_extrinsics_t; 4usize]; 4usize],
    #[doc = "< Depth camera mode for which calibration was obtained."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = "< Color camera resolution for which calibration was obtained."]
    pub color_resolution: k4a_color_resolution_t,
}
#[test]
fn bindgen_test_layout__k4a_calibration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_t>(),
        1032usize,
        concat!("Size of: ", stringify!(_k4a_calibration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).depth_camera_calibration as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(depth_camera_calibration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).color_camera_calibration as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(color_camera_calibration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_calibration_t>())).extrinsics as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(extrinsics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_calibration_t>())).depth_mode as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).color_resolution as *const _ as usize
        },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(color_resolution)
        )
    );
}
impl Default for _k4a_calibration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Calibration type representing device calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_t = _k4a_calibration_t;
#[doc = " Three dimensional floating point vector."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_float3_t {
    #[doc = "< X, Y, Z representation of a vector."]
    pub xyz: k4a_float3_t__xyz,
    #[doc = "< Array representation of a vector."]
    pub v: [f32; 3usize],
}
#[doc = " XYZ or array representation of vector."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct k4a_float3_t__xyz {
    #[doc = "< X component of a vector."]
    pub x: f32,
    #[doc = "< Y component of a vector."]
    pub y: f32,
    #[doc = "< Z component of a vector."]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_k4a_float3_t__xyz() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float3_t__xyz>(),
        12usize,
        concat!("Size of: ", stringify!(k4a_float3_t__xyz))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float3_t__xyz>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float3_t__xyz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_float3_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float3_t>(),
        12usize,
        concat!("Size of: ", stringify!(k4a_float3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float3_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t>())).xyz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t),
            "::",
            stringify!(xyz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t),
            "::",
            stringify!(v)
        )
    );
}
impl Default for k4a_float3_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " IMU sample."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_imu_sample_t {
    #[doc = "< Temperature reading of this sample (Celsius)."]
    pub temperature: f32,
    #[doc = "< Accelerometer sample in meters per second squared."]
    pub acc_sample: k4a_float3_t,
    #[doc = "< Timestamp of the accelerometer in microseconds."]
    pub acc_timestamp_usec: u64,
    #[doc = "< Gyro sample in radians per second."]
    pub gyro_sample: k4a_float3_t,
    #[doc = "< Timestamp of the gyroscope in microseconds"]
    pub gyro_timestamp_usec: u64,
}
#[test]
fn bindgen_test_layout__k4a_imu_sample_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_imu_sample_t>(),
        48usize,
        concat!("Size of: ", stringify!(_k4a_imu_sample_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_imu_sample_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_imu_sample_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).temperature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).acc_sample as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(acc_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_imu_sample_t>())).acc_timestamp_usec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(acc_timestamp_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).gyro_sample as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(gyro_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_imu_sample_t>())).gyro_timestamp_usec as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(gyro_timestamp_usec)
        )
    );
}
impl Default for _k4a_imu_sample_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " IMU sample."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_imu_sample_t = _k4a_imu_sample_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_record_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_record_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_record_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_record_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_record_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_record_t = *mut _k4a_record_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_playback_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_playback_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_playback_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_playback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_playback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_playback_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_playback_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_playback_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_playback_t = *mut _k4a_playback_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_playback_data_block_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_playback_data_block_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_playback_data_block_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_playback_data_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_playback_data_block_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_playback_data_block_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_playback_data_block_t>()))._rsvd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_playback_data_block_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_playback_data_block_t = *mut _k4a_playback_data_block_t;
#[doc = "< The result was successful."]
pub const k4a_stream_result_t_K4A_STREAM_RESULT_SUCCEEDED: k4a_stream_result_t = 0;
#[doc = "< The result was a failure."]
pub const k4a_stream_result_t_K4A_STREAM_RESULT_FAILED: k4a_stream_result_t = 1;
#[doc = "< The end of the data stream was reached."]
pub const k4a_stream_result_t_K4A_STREAM_RESULT_EOF: k4a_stream_result_t = 2;
#[doc = " Return codes returned by Azure Kinect playback API."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_stream_result_t = ::std::os::raw::c_uint;
#[doc = "< Seek relative to the beginning of a recording."]
pub const k4a_playback_seek_origin_t_K4A_PLAYBACK_SEEK_BEGIN: k4a_playback_seek_origin_t = 0;
#[doc = "< Seek relative to the end of a recording."]
pub const k4a_playback_seek_origin_t_K4A_PLAYBACK_SEEK_END: k4a_playback_seek_origin_t = 1;
#[doc = "< Seek to an absolute device timestamp."]
pub const k4a_playback_seek_origin_t_K4A_PLAYBACK_SEEK_DEVICE_TIME: k4a_playback_seek_origin_t = 2;
#[doc = " Playback seeking positions."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_playback_seek_origin_t = ::std::os::raw::c_uint;
#[doc = " Structure containing the device configuration used to record."]
#[doc = ""]
#[doc = " \\see k4a_device_configuration_t"]
#[doc = " \\see k4a_playback_get_record_configuration()"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_record_configuration_t {
    #[doc = " Image format used to record the color camera."]
    pub color_format: k4a_image_format_t,
    #[doc = " Image resolution used to record the color camera."]
    pub color_resolution: k4a_color_resolution_t,
    #[doc = " Mode used to record the depth camera."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = " Frame rate used to record the color and depth camera."]
    pub camera_fps: k4a_fps_t,
    #[doc = " True if the recording contains Color camera frames."]
    pub color_track_enabled: bool,
    #[doc = " True if the recording contains Depth camera frames."]
    pub depth_track_enabled: bool,
    #[doc = " True if the recording contains IR camera frames."]
    pub ir_track_enabled: bool,
    #[doc = " True if the recording contains IMU sample data."]
    pub imu_track_enabled: bool,
    #[doc = " The delay between color and depth images in the recording."]
    #[doc = " A negative delay means depth images are first, and a positive delay means color images are first."]
    pub depth_delay_off_color_usec: i32,
    #[doc = " External synchronization mode"]
    pub wired_sync_mode: k4a_wired_sync_mode_t,
    #[doc = " The delay between this recording and the externally synced master camera."]
    #[doc = " This value is 0 unless \\p wired_sync_mode is set to ::K4A_WIRED_SYNC_MODE_SUBORDINATE"]
    pub subordinate_delay_off_master_usec: u32,
    #[doc = " The timestamp offset of the start of the recording. All recorded timestamps are offset by this value such that"]
    #[doc = " the recording starts at timestamp 0. This value can be used to synchronize timestamps between 2 recording files."]
    pub start_timestamp_offset_usec: u32,
}
#[test]
fn bindgen_test_layout__k4a_record_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_configuration_t>(),
        36usize,
        concat!("Size of: ", stringify!(_k4a_record_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_configuration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_record_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).color_format as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).color_resolution as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(color_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).depth_mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).camera_fps as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(camera_fps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).color_track_enabled as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(color_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).depth_track_enabled as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(depth_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).ir_track_enabled as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(ir_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).imu_track_enabled as *const _
                as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(imu_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).depth_delay_off_color_usec
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(depth_delay_off_color_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).wired_sync_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(wired_sync_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>()))
                .subordinate_delay_off_master_usec as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(subordinate_delay_off_master_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).start_timestamp_offset_usec
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(start_timestamp_offset_usec)
        )
    );
}
impl Default for _k4a_record_configuration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure containing the device configuration used to record."]
#[doc = ""]
#[doc = " \\see k4a_device_configuration_t"]
#[doc = " \\see k4a_playback_get_record_configuration()"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_record_configuration_t = _k4a_record_configuration_t;
#[doc = " Structure containing additional metadata specific to custom video tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_record_video_settings_t {
    #[doc = "< Frame width of the video"]
    pub width: u64,
    #[doc = "< Frame height of the video"]
    pub height: u64,
    #[doc = "< Frame rate (frames-per-second) of the video"]
    pub frame_rate: u64,
}
#[test]
fn bindgen_test_layout__k4a_record_video_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_video_settings_t>(),
        24usize,
        concat!("Size of: ", stringify!(_k4a_record_video_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_video_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_record_video_settings_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_video_settings_t>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_video_settings_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_video_settings_t>())).height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_video_settings_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_video_settings_t>())).frame_rate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_video_settings_t),
            "::",
            stringify!(frame_rate)
        )
    );
}
#[doc = " Structure containing additional metadata specific to custom video tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_record_video_settings_t = _k4a_record_video_settings_t;
#[doc = " Structure containing additional metadata specific to custom subtitle tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _k4a_record_subtitle_settings_t {
    #[doc = " If true, data will be grouped together in batches to reduce overhead. In this mode, only a single timestamp will"]
    #[doc = " be stored per batch, and an estimated timestamp will be used by k4a_playback_seek_timestamp() and"]
    #[doc = " k4a_playback_data_block_get_timestamp_usec(). The estimated timestamp is calculated with the assumption that"]
    #[doc = " blocks are evenly spaced within a batch. If precise timestamps are required, the timestamp should be added to"]
    #[doc = " each data block itself."]
    #[doc = ""]
    #[doc = " If false, data will be stored as individual blocks with full timestamp information (Default)."]
    pub high_freq_data: bool,
}
#[test]
fn bindgen_test_layout__k4a_record_subtitle_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_subtitle_settings_t>(),
        1usize,
        concat!("Size of: ", stringify!(_k4a_record_subtitle_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_subtitle_settings_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_k4a_record_subtitle_settings_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_subtitle_settings_t>())).high_freq_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_subtitle_settings_t),
            "::",
            stringify!(high_freq_data)
        )
    );
}
#[doc = " Structure containing additional metadata specific to custom subtitle tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_record_subtitle_settings_t = _k4a_record_subtitle_settings_t;
pub struct Funcs {
    pub k4a_record_create: unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        device: k4a_device_t,
        device_config: k4a_device_configuration_t,
        recording_handle: *mut k4a_record_t,
    ) -> k4a_result_t,
    pub k4a_record_add_tag: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> k4a_result_t,
    pub k4a_record_add_imu_track:
        unsafe extern "C" fn(recording_handle: k4a_record_t) -> k4a_result_t,
    pub k4a_record_add_attachment: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        attachment_name: *const ::std::os::raw::c_char,
        buffer: *const u8,
        buffer_size: size_t,
    ) -> k4a_result_t,
    pub k4a_record_add_custom_video_track: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        track_name: *const ::std::os::raw::c_char,
        codec_id: *const ::std::os::raw::c_char,
        codec_context: *const u8,
        codec_context_size: size_t,
        track_settings: *const k4a_record_video_settings_t,
    ) -> k4a_result_t,
    pub k4a_record_add_custom_subtitle_track: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        track_name: *const ::std::os::raw::c_char,
        codec_id: *const ::std::os::raw::c_char,
        codec_context: *const u8,
        codec_context_size: size_t,
        track_settings: *const k4a_record_subtitle_settings_t,
    ) -> k4a_result_t,
    pub k4a_record_write_header:
        unsafe extern "C" fn(recording_handle: k4a_record_t) -> k4a_result_t,
    pub k4a_record_write_capture: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        capture_handle: k4a_capture_t,
    ) -> k4a_result_t,
    pub k4a_record_write_imu_sample: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        imu_sample: k4a_imu_sample_t,
    ) -> k4a_result_t,
    pub k4a_record_write_custom_track_data: unsafe extern "C" fn(
        recording_handle: k4a_record_t,
        track_name: *const ::std::os::raw::c_char,
        device_timestamp_usec: u64,
        custom_data: *mut u8,
        custom_data_size: size_t,
    ) -> k4a_result_t,
    pub k4a_record_flush: unsafe extern "C" fn(recording_handle: k4a_record_t) -> k4a_result_t,
    pub k4a_record_close: unsafe extern "C" fn(recording_handle: k4a_record_t),
    pub k4a_playback_open: unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        playback_handle: *mut k4a_playback_t,
    ) -> k4a_result_t,
    pub k4a_playback_get_raw_calibration: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        data: *mut u8,
        data_size: *mut size_t,
    ) -> k4a_buffer_result_t,
    pub k4a_playback_get_calibration: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        calibration: *mut k4a_calibration_t,
    ) -> k4a_result_t,
    pub k4a_playback_get_record_configuration: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        config: *mut k4a_record_configuration_t,
    ) -> k4a_result_t,
    pub k4a_playback_check_track_exists: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
    ) -> bool,
    pub k4a_playback_get_track_count:
        unsafe extern "C" fn(playback_handle: k4a_playback_t) -> size_t,
    pub k4a_playback_get_track_name: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_index: size_t,
        track_name: *mut ::std::os::raw::c_char,
        track_name_size: *mut size_t,
    ) -> k4a_buffer_result_t,
    pub k4a_playback_track_is_builtin: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
    ) -> bool,
    pub k4a_playback_track_get_video_settings: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        video_settings: *mut k4a_record_video_settings_t,
    ) -> k4a_result_t,
    pub k4a_playback_track_get_codec_id: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        codec_id: *mut ::std::os::raw::c_char,
        codec_id_size: *mut size_t,
    ) -> k4a_buffer_result_t,
    pub k4a_playback_track_get_codec_context: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        codec_context: *mut u8,
        codec_context_size: *mut size_t,
    ) -> k4a_buffer_result_t,
    pub k4a_playback_get_tag: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        value_size: *mut size_t,
    ) -> k4a_buffer_result_t,
    pub k4a_playback_set_color_conversion: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        target_format: k4a_image_format_t,
    ) -> k4a_result_t,
    pub k4a_playback_get_attachment: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        file_name: *const ::std::os::raw::c_char,
        data: *mut u8,
        data_size: *mut size_t,
    ) -> k4a_buffer_result_t,
    pub k4a_playback_get_next_capture: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        capture_handle: *mut k4a_capture_t,
    ) -> k4a_stream_result_t,
    pub k4a_playback_get_previous_capture: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        capture_handle: *mut k4a_capture_t,
    ) -> k4a_stream_result_t,
    pub k4a_playback_get_next_imu_sample: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        imu_sample: *mut k4a_imu_sample_t,
    ) -> k4a_stream_result_t,
    pub k4a_playback_get_previous_imu_sample: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        imu_sample: *mut k4a_imu_sample_t,
    ) -> k4a_stream_result_t,
    pub k4a_playback_get_next_data_block: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        data_block_handle: *mut k4a_playback_data_block_t,
    ) -> k4a_stream_result_t,
    pub k4a_playback_get_previous_data_block: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        data_block_handle: *mut k4a_playback_data_block_t,
    ) -> k4a_stream_result_t,
    pub k4a_playback_data_block_get_device_timestamp_usec:
        unsafe extern "C" fn(data_block_handle: k4a_playback_data_block_t) -> u64,
    pub k4a_playback_data_block_get_buffer_size:
        unsafe extern "C" fn(data_block_handle: k4a_playback_data_block_t) -> size_t,
    pub k4a_playback_data_block_get_buffer:
        unsafe extern "C" fn(data_block_handle: k4a_playback_data_block_t) -> *mut u8,
    pub k4a_playback_data_block_release:
        unsafe extern "C" fn(data_block_handle: k4a_playback_data_block_t),
    pub k4a_playback_seek_timestamp: unsafe extern "C" fn(
        playback_handle: k4a_playback_t,
        offset_usec: i64,
        origin: k4a_playback_seek_origin_t,
    ) -> k4a_result_t,
    pub k4a_playback_get_recording_length_usec:
        unsafe extern "C" fn(playback_handle: k4a_playback_t) -> u64,
    pub k4a_playback_get_last_timestamp_usec:
        unsafe extern "C" fn(playback_handle: k4a_playback_t) -> u64,
    pub k4a_playback_close: unsafe extern "C" fn(playback_handle: k4a_playback_t),
}
