/* automatically generated by rust-bindgen 0.59.1 */

pub const _GLIBCXX_CINTTYPES: u32 = 1;
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 9;
pub const __GLIBCXX__: u32 = 20200808;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EBADMSG: u32 = 1;
pub const _GLIBCXX_HAVE_ECANCELED: u32 = 1;
pub const _GLIBCXX_HAVE_ECHILD: u32 = 1;
pub const _GLIBCXX_HAVE_EIDRM: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENODATA: u32 = 1;
pub const _GLIBCXX_HAVE_ENOLINK: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSPC: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSTR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: u32 = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: u32 = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: u32 = 1;
pub const _GLIBCXX_HAVE_EPERM: u32 = 1;
pub const _GLIBCXX_HAVE_EPROTO: u32 = 1;
pub const _GLIBCXX_HAVE_ETIME: u32 = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: u32 = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: u32 = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const K4A_VERSION_MAJOR: u32 = 1;
pub const K4A_VERSION_MINOR: u32 = 4;
pub const K4A_VERSION_PATCH: u32 = 1;
pub const K4A_VERSION_PRERELEASE: &'static [u8; 1usize] = b"\0";
pub const K4A_VERSION_BUILD_METADATA: &'static [u8; 1usize] = b"\0";
pub const K4A_VERSION_STR: &'static [u8; 6usize] = b"1.4.1\0";
pub const _GLIBCXX_CSTDDEF: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _GLIBCXX_CSTRING: u32 = 1;
pub const K4A_DEVICE_DEFAULT: u32 = 0;
pub const K4A_WAIT_INFINITE: i32 = -1;
pub const K4A_TRACK_NAME_COLOR: &'static [u8; 6usize] = b"COLOR\0";
pub const K4A_TRACK_NAME_DEPTH: &'static [u8; 6usize] = b"DEPTH\0";
pub const K4A_TRACK_NAME_IR: &'static [u8; 3usize] = b"IR\0";
pub const K4A_TRACK_NAME_IMU: &'static [u8; 4usize] = b"IMU\0";
pub type std_size_t = ::std::os::raw::c_ulong;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[repr(align(16))]
#[derive(Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn strpbrk(
        __s: *mut ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: size_t,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_device_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_device_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_device_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_device_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_device_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_device_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_device_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_device_t = *mut _k4a_device_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_capture_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_capture_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_capture_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_capture_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_capture_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_capture_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_capture_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_capture_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_capture_t = *mut _k4a_capture_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_image_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_image_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_image_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_image_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_image_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_image_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_image_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_image_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_image_t = *mut _k4a_image_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_transformation_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_transformation_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_transformation_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_transformation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_transformation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_transformation_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_transformation_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_transformation_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_transformation_t = *mut _k4a_transformation_t;
#[doc = "< The result was successful"]
pub const k4a_result_t_K4A_RESULT_SUCCEEDED: k4a_result_t = 0;
#[doc = "< The result was a failure"]
pub const k4a_result_t_K4A_RESULT_FAILED: k4a_result_t = 1;
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_result_t = ::std::os::raw::c_uint;
#[doc = "< The result was successful"]
pub const k4a_buffer_result_t_K4A_BUFFER_RESULT_SUCCEEDED: k4a_buffer_result_t = 0;
#[doc = "< The result was a failure"]
pub const k4a_buffer_result_t_K4A_BUFFER_RESULT_FAILED: k4a_buffer_result_t = 1;
#[doc = "< The input buffer was too small"]
pub const k4a_buffer_result_t_K4A_BUFFER_RESULT_TOO_SMALL: k4a_buffer_result_t = 2;
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_buffer_result_t = ::std::os::raw::c_uint;
#[doc = "< The result was successful"]
pub const k4a_wait_result_t_K4A_WAIT_RESULT_SUCCEEDED: k4a_wait_result_t = 0;
#[doc = "< The result was a failure"]
pub const k4a_wait_result_t_K4A_WAIT_RESULT_FAILED: k4a_wait_result_t = 1;
#[doc = "< The operation timed out"]
pub const k4a_wait_result_t_K4A_WAIT_RESULT_TIMEOUT: k4a_wait_result_t = 2;
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_wait_result_t = ::std::os::raw::c_uint;
#[doc = "< Most severe level of debug messaging."]
pub const k4a_log_level_t_K4A_LOG_LEVEL_CRITICAL: k4a_log_level_t = 0;
#[doc = "< 2nd most severe level of debug messaging."]
pub const k4a_log_level_t_K4A_LOG_LEVEL_ERROR: k4a_log_level_t = 1;
#[doc = "< 3nd most severe level of debug messaging."]
pub const k4a_log_level_t_K4A_LOG_LEVEL_WARNING: k4a_log_level_t = 2;
#[doc = "< 2nd least severe level of debug messaging."]
pub const k4a_log_level_t_K4A_LOG_LEVEL_INFO: k4a_log_level_t = 3;
#[doc = "< Least severe level of debug messaging."]
pub const k4a_log_level_t_K4A_LOG_LEVEL_TRACE: k4a_log_level_t = 4;
#[doc = "< No logging is performed"]
pub const k4a_log_level_t_K4A_LOG_LEVEL_OFF: k4a_log_level_t = 5;
#[doc = " Verbosity levels of debug messaging"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_log_level_t = ::std::os::raw::c_uint;
#[doc = "< Depth sensor will be turned off with this setting."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_OFF: k4a_depth_mode_t = 0;
#[doc = "< Depth captured at 320x288. Passive IR is also captured at 320x288."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_NFOV_2X2BINNED: k4a_depth_mode_t = 1;
#[doc = "< Depth captured at 640x576. Passive IR is also captured at 640x576."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_NFOV_UNBINNED: k4a_depth_mode_t = 2;
#[doc = "< Depth captured at 512x512. Passive IR is also captured at 512x512."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_WFOV_2X2BINNED: k4a_depth_mode_t = 3;
#[doc = "< Depth captured at 1024x1024. Passive IR is also captured at 1024x1024."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_WFOV_UNBINNED: k4a_depth_mode_t = 4;
#[doc = "< Passive IR only, captured at 1024x1024."]
pub const k4a_depth_mode_t_K4A_DEPTH_MODE_PASSIVE_IR: k4a_depth_mode_t = 5;
#[doc = " Depth sensor capture modes."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " See the hardware specification for additional details on the field of view, and supported frame rates"]
#[doc = " for each mode."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " NFOV and WFOV denote Narrow and Wide Field Of View configurations."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Binned modes reduce the captured camera resolution by combining adjacent sensor pixels into a bin."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_depth_mode_t = ::std::os::raw::c_uint;
#[doc = "< Color camera will be turned off with this setting"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_OFF: k4a_color_resolution_t = 0;
#[doc = "< 1280 * 720  16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_720P: k4a_color_resolution_t = 1;
#[doc = "< 1920 * 1080 16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_1080P: k4a_color_resolution_t = 2;
#[doc = "< 2560 * 1440 16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_1440P: k4a_color_resolution_t = 3;
#[doc = "< 2048 * 1536 4:3"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_1536P: k4a_color_resolution_t = 4;
#[doc = "< 3840 * 2160 16:9"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_2160P: k4a_color_resolution_t = 5;
#[doc = "< 4096 * 3072 4:3"]
pub const k4a_color_resolution_t_K4A_COLOR_RESOLUTION_3072P: k4a_color_resolution_t = 6;
#[doc = " Color sensor resolutions."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_color_resolution_t = ::std::os::raw::c_uint;
#[doc = " Color image type MJPG."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The buffer for each image is encoded as a JPEG and can be decoded by a JPEG decoder."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Because the image is compressed, the stride parameter for the \\ref k4a_image_t is not applicable."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each MJPG encoded image in a stream may be of differing size depending on the compression efficiency."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_MJPG: k4a_image_format_t = 0;
#[doc = " Color image type NV12."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " NV12 images separate the luminance and chroma data such that all the luminance is at the"]
#[doc = " beginning of the buffer, and the chroma lines follow immediately after."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each line"]
#[doc = " of the image in memory. Chroma has half as many lines of height and half the width in pixels of the luminance."]
#[doc = " Each chroma line has the same width in bytes as a luminance line."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_NV12: k4a_image_format_t = 1;
#[doc = " Color image type YUY2."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " YUY2 stores chroma and luminance data in interleaved pixels."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_YUY2: k4a_image_format_t = 2;
#[doc = " Color image type BGRA32."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of BGRA32 data is four bytes. The first three bytes represent Blue, Green,"]
#[doc = " and Red data. The fourth byte is the alpha channel and is unused in the Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The Azure Kinect device does not natively capture in this format. Requesting images of this format"]
#[doc = " requires additional computation in the API."]
#[doc = ""]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_COLOR_BGRA32: k4a_image_format_t = 3;
#[doc = " Depth image type DEPTH16."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of DEPTH16 data is two bytes of little endian unsigned depth data. The unit of the data is in"]
#[doc = " millimeters from the origin of the camera."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_DEPTH16: k4a_image_format_t = 4;
#[doc = " Image type IR16."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of IR16 data is two bytes of little endian unsigned depth data. The value of the data represents"]
#[doc = " brightness."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " This format represents infrared light and is captured by the depth camera."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_IR16: k4a_image_format_t = 5;
#[doc = " Single channel image type CUSTOM8."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of CUSTOM8 is a single channel one byte of unsigned data."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_CUSTOM8: k4a_image_format_t = 6;
#[doc = " Single channel image type CUSTOM16."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Each pixel of CUSTOM16 is a single channel two bytes of little endian unsigned data."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
#[doc = " line of the image in memory."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_CUSTOM16: k4a_image_format_t = 7;
#[doc = " Custom image format."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Used in conjunction with user created images or images packing non-standard data."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " See the originator of the custom formatted image for information on how to interpret the data."]
pub const k4a_image_format_t_K4A_IMAGE_FORMAT_CUSTOM: k4a_image_format_t = 8;
#[doc = " Image format type."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The image format indicates how the \\ref k4a_image_t buffer data is interpreted."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_image_format_t = ::std::os::raw::c_uint;
#[doc = "< Nearest neighbor interpolation"]
pub const k4a_transformation_interpolation_type_t_K4A_TRANSFORMATION_INTERPOLATION_TYPE_NEAREST:
    k4a_transformation_interpolation_type_t = 0;
#[doc = "< Linear interpolation"]
pub const k4a_transformation_interpolation_type_t_K4A_TRANSFORMATION_INTERPOLATION_TYPE_LINEAR:
    k4a_transformation_interpolation_type_t = 1;
#[doc = " Transformation interpolation type."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Interpolation type used with k4a_transformation_depth_image_to_color_camera_custom."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_transformation_interpolation_type_t = ::std::os::raw::c_uint;
#[doc = "< 5 FPS"]
pub const k4a_fps_t_K4A_FRAMES_PER_SECOND_5: k4a_fps_t = 0;
#[doc = "< 15 FPS"]
pub const k4a_fps_t_K4A_FRAMES_PER_SECOND_15: k4a_fps_t = 1;
#[doc = "< 30 FPS"]
pub const k4a_fps_t_K4A_FRAMES_PER_SECOND_30: k4a_fps_t = 2;
#[doc = " Color and depth sensor frame rate."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This enumeration is used to select the desired frame rate to operate the cameras. The actual"]
#[doc = " frame rate may vary slightly due to dropped data, synchronization variation between devices,"]
#[doc = " clock accuracy, or if the camera exposure priority mode causes reduced frame rate."]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_fps_t = ::std::os::raw::c_uint;
#[doc = " Exposure time setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May be set to ::K4A_COLOR_CONTROL_MODE_AUTO or ::K4A_COLOR_CONTROL_MODE_MANUAL."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The Azure Kinect supports a limited number of fixed expsore settings. When setting this, expect the exposure to"]
#[doc = " be rounded up to the nearest setting. Exceptions are 1) The last value in the table is the upper limit, so a"]
#[doc = " value larger than this will be overridden to the largest entry in the table. 2) The exposure time cannot be"]
#[doc = " larger than the equivelent FPS. So expect 100ms exposure time to be reduced to 30ms or 33.33ms when the camera is"]
#[doc = " started. The most recent copy of the table 'device_exposure_mapping' is in"]
#[doc = " https://github.com/microsoft/Azure-Kinect-Sensor-SDK/blob/develop/src/color/color_priv.h"]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Exposure time is measured in microseconds."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_EXPOSURE_TIME_ABSOLUTE:
    k4a_color_control_command_t = 0;
#[doc = " Exposure or Framerate priority setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Value of 0 means framerate priority. Value of 1 means exposure priority."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Using exposure priority may impact the framerate of both the color and depth cameras."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Deprecated starting in 1.2.0. Please discontinue usage, firmware does not support this."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_AUTO_EXPOSURE_PRIORITY:
    k4a_color_control_command_t = 1;
#[doc = " Brightness setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The valid range is 0 to 255. The default value is 128."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_BRIGHTNESS: k4a_color_control_command_t = 2;
#[doc = " Contrast setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_CONTRAST: k4a_color_control_command_t = 3;
#[doc = " Saturation setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_SATURATION: k4a_color_control_command_t = 4;
#[doc = " Sharpness setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_SHARPNESS: k4a_color_control_command_t = 5;
#[doc = " White balance setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May be set to ::K4A_COLOR_CONTROL_MODE_AUTO or ::K4A_COLOR_CONTROL_MODE_MANUAL."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " The unit is degrees Kelvin. The setting must be set to a value evenly divisible by 10 degrees."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_WHITEBALANCE: k4a_color_control_command_t =
    6;
#[doc = " Backlight compensation setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Value of 0 means backlight compensation is disabled. Value of 1 means backlight compensation is enabled."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_BACKLIGHT_COMPENSATION:
    k4a_color_control_command_t = 7;
#[doc = " Gain setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_GAIN: k4a_color_control_command_t = 8;
#[doc = " Powerline frequency setting."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
#[doc = ""]
#[doc = " \\details"]
#[doc = " Value of 1 sets the powerline compensation to 50 Hz. Value of 2 sets the powerline compensation to 60 Hz."]
pub const k4a_color_control_command_t_K4A_COLOR_CONTROL_POWERLINE_FREQUENCY:
    k4a_color_control_command_t = 9;
#[doc = " Color sensor control commands"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The current settings can be read with k4a_device_get_color_control(). The settings can be set with"]
#[doc = " k4a_device_set_color_control()."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Control values set on a device are reset only when the device is power cycled. The device will retain the settings"]
#[doc = " even if the \\ref k4a_device_t is closed or the application is restarted."]
#[doc = ""]
#[doc = " \\see k4a_color_control_mode_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_color_control_command_t = ::std::os::raw::c_uint;
#[doc = "< set the associated k4a_color_control_command_t to auto"]
pub const k4a_color_control_mode_t_K4A_COLOR_CONTROL_MODE_AUTO: k4a_color_control_mode_t = 0;
#[doc = "< set the associated k4a_color_control_command_t to manual"]
pub const k4a_color_control_mode_t_K4A_COLOR_CONTROL_MODE_MANUAL: k4a_color_control_mode_t = 1;
#[doc = " Color sensor control mode"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The current settings can be read with k4a_device_get_color_control(). The settings can be set with"]
#[doc = " k4a_device_set_color_control()."]
#[doc = ""]
#[doc = " \\see k4a_color_control_command_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_color_control_mode_t = ::std::os::raw::c_uint;
#[doc = "< Neither 'Sync In' or 'Sync Out' connections are used."]
pub const k4a_wired_sync_mode_t_K4A_WIRED_SYNC_MODE_STANDALONE: k4a_wired_sync_mode_t = 0;
#[doc = "< The 'Sync Out' jack is enabled and synchronization data it driven out the"]
#[doc = "connected wire. While in master mode the color camera must be enabled as part of the"]
#[doc = "multi device sync signalling logic. Even if the color image is not needed, the color"]
#[doc = "camera must be running."]
pub const k4a_wired_sync_mode_t_K4A_WIRED_SYNC_MODE_MASTER: k4a_wired_sync_mode_t = 1;
#[doc = "< The 'Sync In' jack is used for synchronization and 'Sync Out' is driven for the"]
#[doc = "next device in the chain. 'Sync Out' is a mirror of 'Sync In' for this mode."]
pub const k4a_wired_sync_mode_t_K4A_WIRED_SYNC_MODE_SUBORDINATE: k4a_wired_sync_mode_t = 2;
#[doc = " Synchronization mode when connecting two or more devices together."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_wired_sync_mode_t = ::std::os::raw::c_uint;
#[doc = "< Calibration type is unknown"]
pub const k4a_calibration_type_t_K4A_CALIBRATION_TYPE_UNKNOWN: k4a_calibration_type_t = -1;
#[doc = "< Depth sensor"]
pub const k4a_calibration_type_t_K4A_CALIBRATION_TYPE_DEPTH: k4a_calibration_type_t = 0;
#[doc = "< Color sensor"]
pub const k4a_calibration_type_t_K4A_CALIBRATION_TYPE_COLOR: k4a_calibration_type_t = 1;
#[doc = "< Gyroscope sensor"]
pub const k4a_calibration_type_t_K4A_CALIBRATION_TYPE_GYRO: k4a_calibration_type_t = 2;
#[doc = "< Accelerometer sensor"]
pub const k4a_calibration_type_t_K4A_CALIBRATION_TYPE_ACCEL: k4a_calibration_type_t = 3;
#[doc = "< Number of types excluding unknown type"]
pub const k4a_calibration_type_t_K4A_CALIBRATION_TYPE_NUM: k4a_calibration_type_t = 4;
#[doc = " Calibration types."]
#[doc = ""]
#[doc = " Specifies a type of calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_type_t = ::std::os::raw::c_int;
#[doc = "< Calibration model is unknown"]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_UNKNOWN:
    k4a_calibration_model_type_t = 0;
#[doc = "< Deprecated (not supported). Calibration model is Theta (arctan)."]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_THETA:
    k4a_calibration_model_type_t = 1;
#[doc = "< Deprecated (not supported). Calibration model is"]
#[doc = "Polynomial 3K."]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_POLYNOMIAL_3K:
    k4a_calibration_model_type_t = 2;
#[doc = "< Deprecated (only supported early internal devices)."]
#[doc = "Calibration model is Rational 6KT."]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_RATIONAL_6KT:
    k4a_calibration_model_type_t = 3;
#[doc = "< Calibration model is Brown Conrady (compatible with"]
#[doc = " OpenCV)"]
pub const k4a_calibration_model_type_t_K4A_CALIBRATION_LENS_DISTORTION_MODEL_BROWN_CONRADY:
    k4a_calibration_model_type_t = 4;
#[doc = " Calibration model type."]
#[doc = ""]
#[doc = " The model used interpret the calibration parameters."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_model_type_t = ::std::os::raw::c_uint;
#[doc = "< Production firmware."]
pub const k4a_firmware_build_t_K4A_FIRMWARE_BUILD_RELEASE: k4a_firmware_build_t = 0;
#[doc = "< Pre-production firmware."]
pub const k4a_firmware_build_t_K4A_FIRMWARE_BUILD_DEBUG: k4a_firmware_build_t = 1;
#[doc = " Firmware build type."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_firmware_build_t = ::std::os::raw::c_uint;
#[doc = "< Microsoft signed firmware."]
pub const k4a_firmware_signature_t_K4A_FIRMWARE_SIGNATURE_MSFT: k4a_firmware_signature_t = 0;
#[doc = "< Test signed firmware."]
pub const k4a_firmware_signature_t_K4A_FIRMWARE_SIGNATURE_TEST: k4a_firmware_signature_t = 1;
#[doc = "< Unsigned firmware."]
pub const k4a_firmware_signature_t_K4A_FIRMWARE_SIGNATURE_UNSIGNED: k4a_firmware_signature_t = 2;
#[doc = " Firmware signature type."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_firmware_signature_t = ::std::os::raw::c_uint;
#[doc = " Callback function for debug messages being generated by the Azure Kinect SDK."]
#[doc = ""]
#[doc = " \\param context"]
#[doc = " The context of the callback function. This is the context that was supplied by the caller to \\p"]
#[doc = " k4a_set_debug_message_handler."]
#[doc = ""]
#[doc = " \\param level"]
#[doc = " The level of the message that has been created."]
#[doc = ""]
#[doc = " \\param file"]
#[doc = " The file name of the source file that generated the message."]
#[doc = ""]
#[doc = " \\param line"]
#[doc = " The line number of the source file that generated the message."]
#[doc = ""]
#[doc = " \\param message"]
#[doc = " The messaged generated by the Azure Kinect SDK."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The callback is called asynchronously when the Azure Kinext SDK generates a message at a \\p level that is equal to"]
#[doc = " or more critical than the level specified when calling \\ref k4a_set_debug_message_handler() to register the callback."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This callback can occur from any thread and blocks the calling thread. The k4a_logging_message_cb_t function user"]
#[doc = " must protect it's logging resources from concurrent calls. All care should be made to minimize the amount of time"]
#[doc = " locks are held."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[doc = ""]
pub type k4a_logging_message_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        level: k4a_log_level_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Callback function for a memory object being destroyed."]
#[doc = ""]
#[doc = " \\param buffer"]
#[doc = " The buffer pointer that was supplied by the caller as \\p buffer_release_cb to \\ref k4a_image_create_from_buffer()."]
#[doc = ""]
#[doc = " \\param context"]
#[doc = " The context for the memory object that needs to be destroyed that was supplied by the caller as \\p"]
#[doc = " buffer_release_cb_context to \\ref k4a_image_create_from_buffer()."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " When all references for the memory object are released, this callback will be invoked as the final destroy for the"]
#[doc = " given memory."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[doc = ""]
pub type k4a_memory_destroy_cb_t = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
#[doc = " Callback function for a memory allocation."]
#[doc = ""]
#[doc = " \\param size"]
#[doc = " Minimum size in bytes needed for the buffer."]
#[doc = ""]
#[doc = " \\param context"]
#[doc = " Output parameter for a context that will be provided in the subsequent call to the \\ref k4a_memory_destroy_cb_t"]
#[doc = " callback."]
#[doc = ""]
#[doc = " \\return"]
#[doc = " A pointer to the newly allocated memory."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " A callback of this type is provided when there is an application defined allocator."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[doc = ""]
pub type k4a_memory_allocate_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        size: ::std::os::raw::c_int,
        context: *mut *mut ::std::os::raw::c_void,
    ) -> *mut u8,
>;
#[doc = " Configuration parameters for an Azure Kinect device."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4a_device_start_cameras() to specify the configuration of the data capture."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_device_configuration_t {
    #[doc = " Image format to capture with the color camera."]
    #[doc = ""]
    #[doc = " The color camera does not natively produce BGRA32 images."]
    #[doc = " Setting ::K4A_IMAGE_FORMAT_COLOR_BGRA32 for color_format will result in higher CPU utilization."]
    pub color_format: k4a_image_format_t,
    #[doc = " Image resolution to capture with the color camera."]
    pub color_resolution: k4a_color_resolution_t,
    #[doc = " Capture mode for the depth camera."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = " Desired frame rate for the color and depth camera."]
    pub camera_fps: k4a_fps_t,
    #[doc = " Only produce k4a_capture_t objects if they contain synchronized color and depth images."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " This setting controls the behavior in which images are dropped when images are produced faster than they can be"]
    #[doc = " read, or if there are errors in reading images from the device."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " If set to true, \\ref k4a_capture_t objects will only be produced with both color and depth images."]
    #[doc = " If set to false, \\ref k4a_capture_t objects may be produced only a single image when the corresponding image is"]
    #[doc = " dropped."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Setting this to false ensures that the caller receives all of the images received from the camera, regardless of"]
    #[doc = " whether the corresponding images expected in the capture are available."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " If either the color or depth camera are disabled, this setting has no effect."]
    pub synchronized_images_only: bool,
    #[doc = " Desired delay between the capture of the color image and the capture of the depth image."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " A negative value indicates that the depth image should be captured before the color image."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Any value between negative and positive one capture period is valid."]
    pub depth_delay_off_color_usec: i32,
    #[doc = " The external synchronization mode."]
    pub wired_sync_mode: k4a_wired_sync_mode_t,
    #[doc = " The external synchronization timing."]
    #[doc = ""]
    #[doc = " If this camera is a subordinate, this sets the capture delay between the color camera capture and the external"]
    #[doc = " input pulse. A setting of zero indicates that the master and subordinate color images should be aligned."]
    #[doc = ""]
    #[doc = " This setting does not effect the 'Sync out' connection."]
    #[doc = ""]
    #[doc = " This value must be positive and range from zero to one capture period."]
    #[doc = ""]
    #[doc = " If this is not a subordinate, then this value is ignored."]
    pub subordinate_delay_off_master_usec: u32,
    #[doc = " Streaming indicator automatically turns on when the color or depth camera's are in use."]
    #[doc = ""]
    #[doc = " This setting disables that behavior and keeps the LED in an off state."]
    pub disable_streaming_indicator: bool,
}
#[test]
fn bindgen_test_layout__k4a_device_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_device_configuration_t>(),
        36usize,
        concat!("Size of: ", stringify!(_k4a_device_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_device_configuration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_device_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).color_format as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).color_resolution as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(color_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).depth_mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).camera_fps as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(camera_fps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).synchronized_images_only
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(synchronized_images_only)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).depth_delay_off_color_usec
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(depth_delay_off_color_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).wired_sync_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(wired_sync_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>()))
                .subordinate_delay_off_master_usec as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(subordinate_delay_off_master_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).disable_streaming_indicator
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(disable_streaming_indicator)
        )
    );
}
impl Default for _k4a_device_configuration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Configuration parameters for an Azure Kinect device."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4a_device_start_cameras() to specify the configuration of the data capture."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_device_configuration_t = _k4a_device_configuration_t;
#[doc = " Extrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Extrinsic calibration defines the physical relationship between two separate devices."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_calibration_extrinsics_t {
    #[doc = "< 3x3 Rotation matrix stored in row major order"]
    pub rotation: [f32; 9usize],
    #[doc = "< Translation vector, x,y,z (in millimeters)"]
    pub translation: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__k4a_calibration_extrinsics_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_extrinsics_t>(),
        48usize,
        concat!("Size of: ", stringify!(_k4a_calibration_extrinsics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_extrinsics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_extrinsics_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_extrinsics_t>())).rotation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_extrinsics_t),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_extrinsics_t>())).translation as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_extrinsics_t),
            "::",
            stringify!(translation)
        )
    );
}
#[doc = " Extrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Extrinsic calibration defines the physical relationship between two separate devices."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_extrinsics_t = _k4a_calibration_extrinsics_t;
#[doc = " Camera intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_calibration_intrinsic_parameters_t {
    #[doc = "< Individual parameter representation of intrinsic model"]
    pub param: k4a_calibration_intrinsic_parameters_t__param,
    #[doc = "< Array representation of intrinsic model parameters"]
    pub v: [f32; 15usize],
}
#[doc = " individual parameter or array representation of intrinsic model."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k4a_calibration_intrinsic_parameters_t__param {
    #[doc = "< Principal point in image, x"]
    pub cx: f32,
    #[doc = "< Principal point in image, y"]
    pub cy: f32,
    #[doc = "< Focal length x"]
    pub fx: f32,
    #[doc = "< Focal length y"]
    pub fy: f32,
    #[doc = "< k1 radial distortion coefficient"]
    pub k1: f32,
    #[doc = "< k2 radial distortion coefficient"]
    pub k2: f32,
    #[doc = "< k3 radial distortion coefficient"]
    pub k3: f32,
    #[doc = "< k4 radial distortion coefficient"]
    pub k4: f32,
    #[doc = "< k5 radial distortion coefficient"]
    pub k5: f32,
    #[doc = "< k6 radial distortion coefficient"]
    pub k6: f32,
    #[doc = "< Center of distortion in Z=1 plane, x (only used for Rational6KT)"]
    pub codx: f32,
    #[doc = "< Center of distortion in Z=1 plane, y (only used for Rational6KT)"]
    pub cody: f32,
    #[doc = "< Tangential distortion coefficient 2"]
    pub p2: f32,
    #[doc = "< Tangential distortion coefficient 1"]
    pub p1: f32,
    #[doc = "< Metric radius"]
    pub metric_radius: f32,
}
#[test]
fn bindgen_test_layout_k4a_calibration_intrinsic_parameters_t__param() {
    assert_eq!(
        ::std::mem::size_of::<k4a_calibration_intrinsic_parameters_t__param>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_calibration_intrinsic_parameters_t__param>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cy as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).fx as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).fy as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k1 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k2 as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k3 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k4 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k5 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k6 as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).codx
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(codx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cody
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).p2 as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(p2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).p1 as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(p1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).metric_radius
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(metric_radius)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_calibration_intrinsic_parameters_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_calibration_intrinsic_parameters_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(k4a_calibration_intrinsic_parameters_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_calibration_intrinsic_parameters_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(k4a_calibration_intrinsic_parameters_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t>())).param as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t>())).v as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t),
            "::",
            stringify!(v)
        )
    );
}
impl Default for k4a_calibration_intrinsic_parameters_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Camera sensor intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_intrinsics_t {
    #[doc = "< Type of calibration model used"]
    pub type_: k4a_calibration_model_type_t,
    #[doc = "< Number of valid entries in parameters"]
    pub parameter_count: ::std::os::raw::c_uint,
    #[doc = "< Calibration parameters"]
    pub parameters: k4a_calibration_intrinsic_parameters_t,
}
#[test]
fn bindgen_test_layout__k4a_calibration_intrinsics_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_intrinsics_t>(),
        68usize,
        concat!("Size of: ", stringify!(_k4a_calibration_intrinsics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_intrinsics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_intrinsics_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).parameter_count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(parameter_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).parameters as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(parameters)
        )
    );
}
impl Default for _k4a_calibration_intrinsics_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Camera sensor intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_intrinsics_t = _k4a_calibration_intrinsics_t;
#[doc = " Camera calibration contains intrinsic and extrinsic calibration information for a camera."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_camera_t {
    #[doc = "< Extrinsic calibration data."]
    pub extrinsics: k4a_calibration_extrinsics_t,
    #[doc = "< Intrinsic calibration data."]
    pub intrinsics: k4a_calibration_intrinsics_t,
    #[doc = "< Resolution width of the calibration sensor."]
    pub resolution_width: ::std::os::raw::c_int,
    #[doc = "< Resolution height of the calibration sensor."]
    pub resolution_height: ::std::os::raw::c_int,
    #[doc = "< Max FOV of the camera."]
    pub metric_radius: f32,
}
#[test]
fn bindgen_test_layout__k4a_calibration_camera_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_camera_t>(),
        128usize,
        concat!("Size of: ", stringify!(_k4a_calibration_camera_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_camera_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_camera_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).extrinsics as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(extrinsics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).intrinsics as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(intrinsics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).resolution_width as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(resolution_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).resolution_height as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(resolution_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).metric_radius as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(metric_radius)
        )
    );
}
impl Default for _k4a_calibration_camera_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Camera calibration contains intrinsic and extrinsic calibration information for a camera."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_camera_t = _k4a_calibration_camera_t;
#[doc = " Calibration type representing device calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_t {
    #[doc = "< Depth camera calibration."]
    pub depth_camera_calibration: k4a_calibration_camera_t,
    #[doc = "< Color camera calibration."]
    pub color_camera_calibration: k4a_calibration_camera_t,
    #[doc = " Extrinsic transformation parameters."]
    #[doc = ""]
    #[doc = " The extrinsic parameters allow 3D coordinate conversions between depth camera, color camera, the IMU's gyroscope"]
    #[doc = " and accelerometer. To transform from a source to a target 3D coordinate system, use the parameters stored"]
    #[doc = " under extrinsics[source][target]."]
    pub extrinsics: [[k4a_calibration_extrinsics_t; 4usize]; 4usize],
    #[doc = "< Depth camera mode for which calibration was obtained."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = "< Color camera resolution for which calibration was obtained."]
    pub color_resolution: k4a_color_resolution_t,
}
#[test]
fn bindgen_test_layout__k4a_calibration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_t>(),
        1032usize,
        concat!("Size of: ", stringify!(_k4a_calibration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).depth_camera_calibration as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(depth_camera_calibration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).color_camera_calibration as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(color_camera_calibration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_calibration_t>())).extrinsics as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(extrinsics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_calibration_t>())).depth_mode as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).color_resolution as *const _ as usize
        },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(color_resolution)
        )
    );
}
impl Default for _k4a_calibration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Calibration type representing device calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_t = _k4a_calibration_t;
#[doc = " Version information."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_version_t {
    #[doc = "< Major version; represents a breaking change."]
    pub major: u32,
    #[doc = "< Minor version; represents additional features, no regression from lower versions with same"]
    #[doc = "major version."]
    pub minor: u32,
    #[doc = "< Reserved."]
    pub iteration: u32,
}
#[test]
fn bindgen_test_layout__k4a_version_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_version_t>(),
        12usize,
        concat!("Size of: ", stringify!(_k4a_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_version_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_version_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_version_t>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_version_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_version_t>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_version_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_version_t>())).iteration as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_version_t),
            "::",
            stringify!(iteration)
        )
    );
}
#[doc = " Version information."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_version_t = _k4a_version_t;
#[doc = " Structure to define hardware version."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_hardware_version_t {
    #[doc = "< Color camera firmware version."]
    pub rgb: k4a_version_t,
    #[doc = "< Depth camera firmware version."]
    pub depth: k4a_version_t,
    #[doc = "< Audio device firmware version."]
    pub audio: k4a_version_t,
    #[doc = "< Depth sensor firmware version."]
    pub depth_sensor: k4a_version_t,
    #[doc = "< Build type reported by the firmware."]
    pub firmware_build: k4a_firmware_build_t,
    #[doc = "< Signature type of the firmware."]
    pub firmware_signature: k4a_firmware_signature_t,
}
#[test]
fn bindgen_test_layout__k4a_hardware_version_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_hardware_version_t>(),
        56usize,
        concat!("Size of: ", stringify!(_k4a_hardware_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_hardware_version_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_hardware_version_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_hardware_version_t>())).rgb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_hardware_version_t>())).depth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_hardware_version_t>())).audio as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_hardware_version_t>())).depth_sensor as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(depth_sensor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_hardware_version_t>())).firmware_build as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(firmware_build)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_hardware_version_t>())).firmware_signature as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(firmware_signature)
        )
    );
}
impl Default for _k4a_hardware_version_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure to define hardware version."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_hardware_version_t = _k4a_hardware_version_t;
#[doc = " Two dimensional floating point vector."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_float2_t {
    #[doc = "< X, Y representation of a vector"]
    pub xy: k4a_float2_t__xy,
    #[doc = "< Array representation of a vector"]
    pub v: [f32; 2usize],
}
#[doc = " XY or array representation of vector"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k4a_float2_t__xy {
    #[doc = "< X component of a vector"]
    pub x: f32,
    #[doc = "< Y component of a vector"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_k4a_float2_t__xy() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float2_t__xy>(),
        8usize,
        concat!("Size of: ", stringify!(k4a_float2_t__xy))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float2_t__xy>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float2_t__xy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t__xy>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t__xy),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t__xy>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t__xy),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_float2_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float2_t>(),
        8usize,
        concat!("Size of: ", stringify!(k4a_float2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float2_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float2_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t>())).xy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t),
            "::",
            stringify!(v)
        )
    );
}
impl Default for k4a_float2_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Three dimensional floating point vector."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_float3_t {
    #[doc = "< X, Y, Z representation of a vector."]
    pub xyz: k4a_float3_t__xyz,
    #[doc = "< Array representation of a vector."]
    pub v: [f32; 3usize],
}
#[doc = " XYZ or array representation of vector."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k4a_float3_t__xyz {
    #[doc = "< X component of a vector."]
    pub x: f32,
    #[doc = "< Y component of a vector."]
    pub y: f32,
    #[doc = "< Z component of a vector."]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_k4a_float3_t__xyz() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float3_t__xyz>(),
        12usize,
        concat!("Size of: ", stringify!(k4a_float3_t__xyz))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float3_t__xyz>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float3_t__xyz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_float3_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float3_t>(),
        12usize,
        concat!("Size of: ", stringify!(k4a_float3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float3_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t>())).xyz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t),
            "::",
            stringify!(xyz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t),
            "::",
            stringify!(v)
        )
    );
}
impl Default for k4a_float3_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " IMU sample."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_imu_sample_t {
    #[doc = "< Temperature reading of this sample (Celsius)."]
    pub temperature: f32,
    #[doc = "< Accelerometer sample in meters per second squared."]
    pub acc_sample: k4a_float3_t,
    #[doc = "< Timestamp of the accelerometer in microseconds."]
    pub acc_timestamp_usec: u64,
    #[doc = "< Gyro sample in radians per second."]
    pub gyro_sample: k4a_float3_t,
    #[doc = "< Timestamp of the gyroscope in microseconds"]
    pub gyro_timestamp_usec: u64,
}
#[test]
fn bindgen_test_layout__k4a_imu_sample_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_imu_sample_t>(),
        48usize,
        concat!("Size of: ", stringify!(_k4a_imu_sample_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_imu_sample_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_imu_sample_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).temperature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).acc_sample as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(acc_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_imu_sample_t>())).acc_timestamp_usec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(acc_timestamp_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).gyro_sample as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(gyro_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_imu_sample_t>())).gyro_timestamp_usec as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(gyro_timestamp_usec)
        )
    );
}
impl Default for _k4a_imu_sample_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " IMU sample."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_imu_sample_t = _k4a_imu_sample_t;
extern "C" {
    #[doc = " Initial configuration setting for disabling all sensors."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this setting to initialize a \\ref k4a_device_configuration_t to a disabled state."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    #[link_name = "\u{1}_ZL34K4A_DEVICE_CONFIG_INIT_DISABLE_ALL"]
    pub static K4A_DEVICE_CONFIG_INIT_DISABLE_ALL: k4a_device_configuration_t;
}
extern "C" {
    #[doc = " Gets the number of connected devices"]
    #[doc = ""]
    #[doc = " \\returns Number of sensors connected to the PC."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This API counts the number of Azure Kinect devices connected to the host PC."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_installed_count() -> u32;
}
extern "C" {
    #[doc = " Sets and clears the callback function to receive debug messages from the Azure Kinect device."]
    #[doc = ""]
    #[doc = " \\param message_cb"]
    #[doc = " The callback function to receive messages from. Set to NULL to unregister the callback function."]
    #[doc = ""]
    #[doc = " \\param message_cb_context"]
    #[doc = " The callback functions context."]
    #[doc = ""]
    #[doc = " \\param min_level"]
    #[doc = " The least critical error the user wants to be notified about."]
    #[doc = ""]
    #[doc = " \\return ::K4A_RESULT_SUCCEEDED if the callback function was set or cleared successfully. ::K4A_RESULT_FAILED if an"]
    #[doc = " error is encountered or the callback function has already been set."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to set or clear the callback function that is used to deliver debug messages to the caller. This"]
    #[doc = " callback may be called concurrently, it is up to the implementation of the callback function to ensure the"]
    #[doc = " parallelization is handled."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Clearing the callback function will block until all pending calls to the callback function have completed."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " To update \\p min_level, \\p k4a_set_debug_message_handler can be called with the same value \\p message_cb and by"]
    #[doc = " specifying a new \\p min_level."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Logging provided via this API is independent of the logging controlled by the environmental variable controls \\p"]
    #[doc = " K4A_ENABLE_LOG_TO_STDOUT, \\p K4A_ENABLE_LOG_TO_A_FILE, and \\p K4A_LOG_LEVEL. However there is a slight change in"]
    #[doc = " default behavior when using this function. By default, when \\p k4a_set_debug_message_handler() has not been used to"]
    #[doc = " register a message callback, the default for environmental variable controls is to send debug messages as if"]
    #[doc = " K4A_ENABLE_LOG_TO_STDOUT=1 were set. If \\p k4a_set_debug_message_handler registers a callback function before"]
    #[doc = " k4a_device_open() is called, then the default for environmental controls is as if K4A_ENABLE_LOG_TO_STDOUT=0 was"]
    #[doc = " specified. Physically specifying the environmental control will override the default."]
    #[doc = ""]
    #[doc = " \\p min_level"]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_set_debug_message_handler(
        message_cb: k4a_logging_message_cb_t,
        message_cb_context: *mut ::std::os::raw::c_void,
        min_level: k4a_log_level_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Sets the callback functions for the SDK allocator"]
    #[doc = ""]
    #[doc = " \\param allocate"]
    #[doc = " The callback function to allocate memory. When the SDK requires memory allocation this callback will be"]
    #[doc = " called and the application can provide a buffer and a context."]
    #[doc = ""]
    #[doc = " \\param free"]
    #[doc = " The callback function to free memory. The SDK will call this function when memory allocated by \\p allocate"]
    #[doc = " is no longer needed."]
    #[doc = ""]
    #[doc = " \\return ::K4A_RESULT_SUCCEEDED if the callback function was set or cleared successfully. ::K4A_RESULT_FAILED if an"]
    #[doc = " error is encountered or the callback function has already been set."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to hook memory allocation by the SDK. Calling with both \\p allocate and \\p free as NULL will"]
    #[doc = " clear the hook and reset to the default allocator."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If this function is called after memory has been allocated, the previous version of \\p free function may still be"]
    #[doc = " called in the future. The SDK will always call the \\p free function that was set at the time that the memory"]
    #[doc = " was allocated."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Not all memory allocation by the SDK is performed by this allocate function. Small allocations or allocations"]
    #[doc = " from special pools may come from other sources."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_set_allocator(
        allocate: k4a_memory_allocate_cb_t,
        free: k4a_memory_destroy_cb_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Open an Azure Kinect device."]
    #[doc = ""]
    #[doc = " \\param index"]
    #[doc = " The index of the device to open, starting with 0. Optionally pass in #K4A_DEVICE_DEFAULT."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Output parameter which on success will return a handle to the device."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\return ::K4A_RESULT_SUCCEEDED if the device was opened successfully."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If successful, k4a_device_open() will return a device handle in the device_handle parameter."]
    #[doc = " This handle grants exclusive access to the device and may be used in the other Azure Kinect API calls."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When done with the device, close the handle with k4a_device_close()"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_open(index: u32, device_handle: *mut k4a_device_t) -> k4a_result_t;
}
extern "C" {
    #[doc = " Closes an Azure Kinect device."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks Once closed, the handle is no longer valid."]
    #[doc = ""]
    #[doc = " \\remarks Before closing the handle to the device, ensure that all \\ref k4a_capture_t captures have been released with"]
    #[doc = " k4a_capture_release()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_close(device_handle: k4a_device_t);
}
extern "C" {
    #[doc = " Reads a sensor capture."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " If successful this contains a handle to a capture object. Caller must call k4a_capture_release() when its done using"]
    #[doc = " this capture."]
    #[doc = ""]
    #[doc = " \\param timeout_in_ms"]
    #[doc = " Specifies the time in milliseconds the function should block waiting for the capture. If set to 0, the function will"]
    #[doc = " return without blocking. Passing a value of #K4A_WAIT_INFINITE will block indefinitely until data is available, the"]
    #[doc = " device is disconnected, or another error occurs."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_WAIT_RESULT_SUCCEEDED if a capture is returned. If a capture is not available before the timeout elapses, the"]
    #[doc = " function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Gets the next capture in the streamed sequence of captures from the camera. If a new capture is not currently"]
    #[doc = " available, this function will block until the timeout is reached. The SDK will buffer at least two captures worth"]
    #[doc = " of data before dropping the oldest capture. Callers needing to capture all data need to ensure they read the data as"]
    #[doc = " fast as the data is being produced on average."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Upon successfully reading a capture this function will return success and populate \\p capture."]
    #[doc = " If a capture is not available in the configured \\p timeout_in_ms, then the API will return ::K4A_WAIT_RESULT_TIMEOUT."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If the call is successful and a capture is returned, callers must call k4a_capture_release() to return the allocated"]
    #[doc = " memory."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function needs to be called while the device is in a running state;"]
    #[doc = " after k4a_device_start_cameras() is called and before k4a_device_stop_cameras() is called."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function returns an error when an internal problem is encountered; such as loss of the USB connection, inability"]
    #[doc = " to allocate enough memory, and other unexpected issues. Any error returned by this function signals the end of"]
    #[doc = " streaming data, and caller should stop the stream using k4a_device_stop_cameras()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If this function is waiting for data (non-zero timeout) when k4a_device_stop_cameras() or k4a_device_close() is"]
    #[doc = " called on another thread, this function will return an error."]
    #[doc = ""]
    #[doc = " \\returns ::K4A_WAIT_RESULT_SUCCEEDED if a capture is returned. If a capture is not available before the timeout"]
    #[doc = " elapses, the function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    #[doc = ""]
    pub fn k4a_device_get_capture(
        device_handle: k4a_device_t,
        capture_handle: *mut k4a_capture_t,
        timeout_in_ms: i32,
    ) -> k4a_wait_result_t;
}
extern "C" {
    #[doc = " Reads an IMU sample."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param imu_sample"]
    #[doc = " Pointer to the location for the API to write the IMU sample."]
    #[doc = ""]
    #[doc = " \\param timeout_in_ms"]
    #[doc = " Specifies the time in milliseconds the function should block waiting for the sample. If set to 0, the function will"]
    #[doc = " return without blocking. Passing a value of #K4A_WAIT_INFINITE will block indefinitely until data is available, the"]
    #[doc = " device is disconnected, or another error occurs."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_WAIT_RESULT_SUCCEEDED if a sample is returned. If a sample is not available before the timeout elapses, the"]
    #[doc = " function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Gets the next sample in the streamed sequence of IMU samples from the device. If a new sample is not currently"]
    #[doc = " available, this function will block until the timeout is reached. The API will buffer at least two camera capture"]
    #[doc = " intervals worth of samples before dropping the oldest sample. Callers needing to capture all data need to ensure they"]
    #[doc = " read the data as fast as the data is being produced on average."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Upon successfully reading a sample this function will return success and populate \\p imu_sample."]
    #[doc = " If a sample is not available in the configured \\p timeout_in_ms, then the API will return ::K4A_WAIT_RESULT_TIMEOUT."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function needs to be called while the device is in a running state;"]
    #[doc = " after k4a_device_start_imu() is called and before k4a_device_stop_imu() is called."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function returns an error when an internal problem is encountered; such as loss of the USB connection, inability"]
    #[doc = " to allocate enough memory, and other unexpected issues. Any error returned by this function signals the end of"]
    #[doc = " streaming data, and caller should stop the stream using k4a_device_stop_imu()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If this function is waiting for data (non-zero timeout) when k4a_device_stop_imu() or k4a_device_close() is"]
    #[doc = " called on another thread, this function will return an error."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The memory the IMU sample is written to is allocated and owned by the caller, so there is no need to call an Azure"]
    #[doc = " Kinect API to free or release the sample."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_imu_sample(
        device_handle: k4a_device_t,
        imu_sample: *mut k4a_imu_sample_t,
        timeout_in_ms: i32,
    ) -> k4a_wait_result_t;
}
extern "C" {
    #[doc = " Create an empty capture object."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Pointer to a location to store the handle."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to create a \\ref k4a_capture_t handle for a new capture. Release it with k4a_capture_release()."]
    #[doc = ""]
    #[doc = " The new capture is created with a reference count of 1."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns #K4A_RESULT_SUCCEEDED on success. Errors are indicated with #K4A_RESULT_FAILED and error specific data can be"]
    #[doc = " found in the log."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_create(capture_handle: *mut k4a_capture_t) -> k4a_result_t;
}
extern "C" {
    #[doc = " Release a capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture to release."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function when finished using the capture."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_release(capture_handle: k4a_capture_t);
}
extern "C" {
    #[doc = " Add a reference to a capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture to add a reference to."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to add an additional reference to a capture. This reference must be removed with"]
    #[doc = " k4a_capture_release()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_reference(capture_handle: k4a_capture_t);
}
extern "C" {
    #[doc = " Get the color image associated with the given capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle containing the image."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to access the color image part of this capture. Release the \\ref k4a_image_t with"]
    #[doc = " k4a_image_release();"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_get_color_image(capture_handle: k4a_capture_t) -> k4a_image_t;
}
extern "C" {
    #[doc = " Get the depth image associated with the given capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle containing the image."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to access the depth image part of this capture. Release the \\ref k4a_image_t with"]
    #[doc = " k4a_image_release();"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_get_depth_image(capture_handle: k4a_capture_t) -> k4a_image_t;
}
extern "C" {
    #[doc = " Get the IR image associated with the given capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle containing the image."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to access the IR image part of this capture. Release the \\ref k4a_image_t with"]
    #[doc = " k4a_image_release();"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_get_ir_image(capture_handle: k4a_capture_t) -> k4a_image_t;
}
extern "C" {
    #[doc = " Set or add a color image to the associated capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle to hold the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Image handle containing the image."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When a \\ref k4a_image_t is added to a \\ref k4a_capture_t, the \\ref k4a_capture_t will automatically add a reference"]
    #[doc = " to the \\ref k4a_image_t."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If there is already a color image contained in the capture, the existing image will be dereferenced and replaced with"]
    #[doc = " the new image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " To remove a color image to the capture without adding a new image, this function can be called with a NULL"]
    #[doc = " image_handle."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Any \\ref k4a_image_t contained in this \\ref k4a_capture_t will automatically be dereferenced when all references to"]
    #[doc = " the \\ref k4a_capture_t are released with k4a_capture_release()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_set_color_image(capture_handle: k4a_capture_t, image_handle: k4a_image_t);
}
extern "C" {
    #[doc = " Set or add a depth image to the associated capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle to hold the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Image handle containing the image."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When a \\ref k4a_image_t is added to a \\ref k4a_capture_t, the \\ref k4a_capture_t will automatically add a reference"]
    #[doc = " to the \\ref k4a_image_t."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If there is already an image depth image contained in the capture, the existing image will be dereferenced and"]
    #[doc = " replaced with the new image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " To remove a depth image to the capture without adding a new image, this function can be called with a NULL"]
    #[doc = " image_handle."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Any \\ref k4a_image_t contained in this \\ref k4a_capture_t will automatically be dereferenced when all references to"]
    #[doc = " the \\ref k4a_capture_t are released with k4a_capture_release()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_set_depth_image(capture_handle: k4a_capture_t, image_handle: k4a_image_t);
}
extern "C" {
    #[doc = " Set or add an IR image to the associated capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle to hold the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Image handle containing the image."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When a \\ref k4a_image_t is added to a \\ref k4a_capture_t, the \\ref k4a_capture_t will automatically add a reference"]
    #[doc = " to the \\ref k4a_image_t."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If there is already an IR image contained in the capture, the existing image will be dereferenced and replaced with"]
    #[doc = " the new image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " To remove a IR image to the capture without adding a new image, this function can be called with a NULL image_handle."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Any \\ref k4a_image_t contained in this \\ref k4a_capture_t will automatically be dereferenced when all references to"]
    #[doc = " the \\ref k4a_capture_t are released with k4a_capture_release()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_set_ir_image(capture_handle: k4a_capture_t, image_handle: k4a_image_t);
}
extern "C" {
    #[doc = " Set the temperature associated with the capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle to set the temperature on."]
    #[doc = ""]
    #[doc = " \\param temperature_c"]
    #[doc = " Temperature in Celsius to store."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_set_temperature_c(capture_handle: k4a_capture_t, temperature_c: f32);
}
extern "C" {
    #[doc = " Get the temperature associated with the capture."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " Capture handle to retrieve the temperature from."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = " This function returns the temperature of the device at the time of the capture in Celsius. If"]
    #[doc = " the temperature is unavailable, the function will return NAN."]
    #[doc = ""]
    #[doc = " \\relates k4a_capture_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_capture_get_temperature_c(capture_handle: k4a_capture_t) -> f32;
}
extern "C" {
    #[doc = " Create an image."]
    #[doc = ""]
    #[doc = " \\param format"]
    #[doc = " The format of the image that will be stored in this image container."]
    #[doc = ""]
    #[doc = " \\param width_pixels"]
    #[doc = " Width in pixels."]
    #[doc = ""]
    #[doc = " \\param height_pixels"]
    #[doc = " Height in pixels."]
    #[doc = ""]
    #[doc = " \\param stride_bytes"]
    #[doc = " The number of bytes per horizontal line of the image."]
    #[doc = " If set to 0, the stride will be set to the minimum size given the \\p format and \\p width_pixels."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Pointer to store image handle in."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function is used to create images of formats that have consistent stride. The function is not suitable for"]
    #[doc = " compressed formats that may not be represented by the same number of bytes per line."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " For most image formats, the function will allocate an image buffer of size \\p height_pixels * \\p stride_bytes."]
    #[doc = " Buffers #K4A_IMAGE_FORMAT_COLOR_NV12 format will allocate an additional \\p height_pixels / 2 set of lines (each of \\p"]
    #[doc = " stride_bytes). This function cannot be used to allocate #K4A_IMAGE_FORMAT_COLOR_MJPG buffers."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " To create an image object without the API allocating memory, or to represent an image that has a non-deterministic"]
    #[doc = " stride, use k4a_image_create_from_buffer()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\ref k4a_image_t is created with a reference count of 1."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When finished using the created image, release it with k4a_image_release."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns #K4A_RESULT_SUCCEEDED on success. Errors are indicated with #K4A_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_create(
        format: k4a_image_format_t,
        width_pixels: ::std::os::raw::c_int,
        height_pixels: ::std::os::raw::c_int,
        stride_bytes: ::std::os::raw::c_int,
        image_handle: *mut k4a_image_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Create an image from a pre-allocated buffer."]
    #[doc = ""]
    #[doc = " \\param format"]
    #[doc = " The format of the image that will be stored in this image container."]
    #[doc = ""]
    #[doc = " \\param width_pixels"]
    #[doc = " Width in pixels."]
    #[doc = ""]
    #[doc = " \\param height_pixels"]
    #[doc = " Height in pixels."]
    #[doc = ""]
    #[doc = " \\param stride_bytes"]
    #[doc = " The number of bytes per horizontal line of the image."]
    #[doc = ""]
    #[doc = " \\param buffer"]
    #[doc = " Pointer to a pre-allocated image buffer."]
    #[doc = ""]
    #[doc = " \\param buffer_size"]
    #[doc = " Size in bytes of the pre-allocated image buffer."]
    #[doc = ""]
    #[doc = " \\param buffer_release_cb"]
    #[doc = " Callback to the buffer free function, called when all references to the buffer have been released. This parameter is"]
    #[doc = " optional."]
    #[doc = ""]
    #[doc = " \\param buffer_release_cb_context"]
    #[doc = " Context for the buffer free function. This value will be called as a parameter to \\p buffer_release_cb when"]
    #[doc = " the callback is invoked."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Pointer to store image handle in."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function creates a \\ref k4a_image_t from a pre-allocated buffer. When all references to this object reach zero"]
    #[doc = " the provided \\p buffer_release_cb callback function is called so that the memory can be released. If this function"]
    #[doc = " fails, the API will not use the memory provided in \\p buffer, and the API will not call \\p buffer_release_cb."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\ref k4a_image_t is created with a reference count of 1."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Release the reference on this function with k4a_image_release()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns #K4A_RESULT_SUCCEEDED on success. Errors are indicated with #K4A_RESULT_FAILED and error specific data can be"]
    #[doc = " found in the log."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_create_from_buffer(
        format: k4a_image_format_t,
        width_pixels: ::std::os::raw::c_int,
        height_pixels: ::std::os::raw::c_int,
        stride_bytes: ::std::os::raw::c_int,
        buffer: *mut u8,
        buffer_size: size_t,
        buffer_release_cb: k4a_memory_destroy_cb_t,
        buffer_release_cb_context: *mut ::std::os::raw::c_void,
        image_handle: *mut k4a_image_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the image buffer."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this buffer to access the raw image data."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The function will return NULL if there is an error, and will normally return a pointer to the image buffer."]
    #[doc = " Since all \\ref k4a_image_t instances are created with an image buffer, this function should only return NULL if the"]
    #[doc = " \\p image_handle is invalid."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_buffer(image_handle: k4a_image_t) -> *mut u8;
}
extern "C" {
    #[doc = " Get the image buffer size."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function to know what the size of the image buffer is returned by k4a_image_get_buffer()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The function will return 0 if there is an error, and will normally return the image size."]
    #[doc = " Since all \\ref k4a_image_t instances are created with an image buffer, this function should only return 0 if the"]
    #[doc = " \\p image_handle is invalid."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_size(image_handle: k4a_image_t) -> size_t;
}
extern "C" {
    #[doc = " Get the format of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function to determine the format of the image buffer."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " This function is not expected to fail, all \\ref k4a_image_t's are created with a known format. If the"]
    #[doc = " \\p image_handle is invalid, the function will return ::K4A_IMAGE_FORMAT_CUSTOM."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_format(image_handle: k4a_image_t) -> k4a_image_format_t;
}
extern "C" {
    #[doc = " Get the image width in pixels."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " This function is not expected to fail, all \\ref k4a_image_t's are created with a known width. If the \\p"]
    #[doc = " image_handle is invalid, the function will return 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_width_pixels(image_handle: k4a_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the image height in pixels."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " This function is not expected to fail, all \\ref k4a_image_t's are created with a known height. If the \\p"]
    #[doc = " image_handle is invalid, the function will return 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_height_pixels(image_handle: k4a_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the image stride in bytes."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " This function is not expected to fail, all \\ref k4a_image_t's are created with a known stride. If the"]
    #[doc = " \\p image_handle is invalid, or the image's format does not have a stride, the function will return 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_stride_bytes(image_handle: k4a_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the image's device timestamp in microseconds."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Returns the device timestamp of the image. Timestamps are recorded by the device and represent the mid-point of"]
    #[doc = " exposure. They may be used for relative comparison, but their absolute value has no defined meaning."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " If the \\p image_handle is invalid or if no timestamp was set for the image,"]
    #[doc = " this function will return 0. It is also possible for 0 to be a valid timestamp originating from the beginning"]
    #[doc = " of a recording or the start of streaming."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = " Deprecated starting in 1.2.0. Please use k4a_image_get_device_timestamp_usec()."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_timestamp_usec(image_handle: k4a_image_t) -> u64;
}
extern "C" {
    #[doc = " Get the image's device timestamp in microseconds."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Returns the device timestamp of the image, as captured by the hardware. Timestamps are recorded by the device and"]
    #[doc = " represent the mid-point of exposure. They may be used for relative comparison, but their absolute value has no"]
    #[doc = " defined meaning."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " If the \\p image_handle is invalid or if no timestamp was set for the image, this function will return 0. It is also"]
    #[doc = " possible for 0 to be a valid timestamp originating from the beginning of a recording or the start of streaming."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_device_timestamp_usec(image_handle: k4a_image_t) -> u64;
}
extern "C" {
    #[doc = " Get the image's system timestamp in nanoseconds."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Returns the system timestamp of the image. Timestamps are recorded by the host. They may be used for relative"]
    #[doc = " comparision, as they are relative to the corresponding system clock. The absolute value is a monotonic count from"]
    #[doc = " an arbitrary point in the past."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The system timestamp is captured at the moment host PC finishes receiving the image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " On Linux the system timestamp is read from clock_gettime(CLOCK_MONOTONIC), which measures realtime and is not"]
    #[doc = " impacted by adjustments to the system clock. It starts from an arbitrary point in the past. On Windows the system"]
    #[doc = " timestamp is read from QueryPerformanceCounter(), it also measures realtime and is not impacted by adjustments to the"]
    #[doc = " system clock. It also starts from an arbitrary point in the past."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " If the \\p image_handle is invalid or if no timestamp was set for the image, this function will return 0. It is also"]
    #[doc = " possible for 0 to be a valid timestamp originating from the beginning of a recording or the start of streaming."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_system_timestamp_nsec(image_handle: k4a_image_t) -> u64;
}
extern "C" {
    #[doc = " Get the image exposure in microseconds."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Returns an exposure time in microseconds. This is only supported on color image formats."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " If the \\p image_handle is invalid, or no exposure was set on the image, the function will return 0. Otherwise,"]
    #[doc = " it will return the image exposure time in microseconds."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_exposure_usec(image_handle: k4a_image_t) -> u64;
}
extern "C" {
    #[doc = " Get the image white balance."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Returns the image's white balance. This function is only valid for color captures, and not for depth or IR captures."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns the image white balance in Kelvin. If \\p image_handle is invalid, or the white balance was not set or"]
    #[doc = " not applicable to the image, the function will return 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_white_balance(image_handle: k4a_image_t) -> u32;
}
extern "C" {
    #[doc = " Get the image ISO speed."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function is only valid for color captures, and not for depth  or IR captures."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns the ISO speed of the image. 0 indicates the ISO speed was not available or an error occurred."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_get_iso_speed(image_handle: k4a_image_t) -> u32;
}
extern "C" {
    #[doc = " Set the device time stamp, in microseconds, of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the timestamp on."]
    #[doc = ""]
    #[doc = " \\param timestamp_usec"]
    #[doc = " Device timestamp of the image in microseconds."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The device timestamp represents the mid-point of exposure of the image, as captured by the hardware."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_device_timestamp_usec(image_handle: k4a_image_t, timestamp_usec: u64);
}
extern "C" {
    #[doc = " Set the device time stamp, in microseconds, of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the timestamp on."]
    #[doc = ""]
    #[doc = " \\param timestamp_usec"]
    #[doc = " Device timestamp of the image in microseconds."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The device timestamp represents the mid-point of exposure of the image, as captured by the hardware."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = " Deprecated starting in 1.2.0. Please use k4a_image_set_device_timestamp_usec()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_timestamp_usec(image_handle: k4a_image_t, timestamp_usec: u64);
}
extern "C" {
    #[doc = " Set the system time stamp, in nanoseconds, of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the timestamp on."]
    #[doc = ""]
    #[doc = " \\param timestamp_nsec"]
    #[doc = " Timestamp of the image in nanoseconds."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The system timestamp is a high performance and increasing clock (from boot). The timestamp represents the time"]
    #[doc = " immediately after the image buffer was read by the host PC."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_system_timestamp_nsec(image_handle: k4a_image_t, timestamp_nsec: u64);
}
extern "C" {
    #[doc = " Set the exposure time, in microseconds, of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the exposure time on."]
    #[doc = ""]
    #[doc = " \\param exposure_usec"]
    #[doc = " Exposure time of the image in microseconds."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t. An exposure time of 0 is considered invalid. Only color image formats are expected to have a valid"]
    #[doc = " exposure time."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_exposure_usec(image_handle: k4a_image_t, exposure_usec: u64);
}
extern "C" {
    #[doc = " Set the exposure time, in microseconds, of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the exposure time on."]
    #[doc = ""]
    #[doc = " \\param exposure_usec"]
    #[doc = " Exposure time of the image in microseconds."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t. An exposure time of 0 is considered invalid. Only color image formats are expected to have a valid"]
    #[doc = " exposure time."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = " Deprecated starting in 1.2.0. Please use k4a_image_set_exposure_usec()."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_exposure_time_usec(image_handle: k4a_image_t, exposure_usec: u64);
}
extern "C" {
    #[doc = " Set the white balance of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the white balance on."]
    #[doc = ""]
    #[doc = " \\param white_balance"]
    #[doc = " White balance of the image in degrees Kelvin."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t. A white balance of 0 is considered invalid. White balance is only meaningful for color images,"]
    #[doc = " and not expected on depth or IR images."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_white_balance(image_handle: k4a_image_t, white_balance: u32);
}
extern "C" {
    #[doc = " Set the ISO speed of the image."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image to set the ISO speed on."]
    #[doc = ""]
    #[doc = " \\param iso_speed"]
    #[doc = " ISO speed of the image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a"]
    #[doc = " \\ref k4a_image_t. An ISO speed of 0 is considered invalid. Only color images are expected to have a valid ISO speed."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_set_iso_speed(image_handle: k4a_image_t, iso_speed: u32);
}
extern "C" {
    #[doc = " Add a reference to the k4a_image_t."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " References manage the lifetime of the object. When the references reach zero the object is destroyed. A caller must"]
    #[doc = " not access the object after its reference is released."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_reference(image_handle: k4a_image_t);
}
extern "C" {
    #[doc = " Remove a reference from the k4a_image_t."]
    #[doc = ""]
    #[doc = " \\param image_handle"]
    #[doc = " Handle of the image for which the get operation is performed on."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " References manage the lifetime of the object. When the references reach zero the object is destroyed. A caller must"]
    #[doc = " not access the object after its reference is released."]
    #[doc = ""]
    #[doc = " \\relates k4a_image_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_image_release(image_handle: k4a_image_t);
}
extern "C" {
    #[doc = " Starts color and depth camera capture."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param config"]
    #[doc = " The configuration we want to run the device in. This can be initialized with ::K4A_DEVICE_CONFIG_INIT_DISABLE_ALL."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED is returned on success."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Individual sensors configured to run will now start to stream captured data."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " It is not valid to call k4a_device_start_cameras() a second time on the same \\ref k4a_device_t until"]
    #[doc = " k4a_device_stop_cameras() has been called."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_start_cameras(
        device_handle: k4a_device_t,
        config: *const k4a_device_configuration_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Stops the color and depth camera capture."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The streaming of individual sensors stops as a result of this call. Once called, k4a_device_start_cameras() may"]
    #[doc = " be called again to resume sensor streaming."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function may be called while another thread is blocking in k4a_device_get_capture()."]
    #[doc = " Calling this function while another thread is in that function will result in that function returning a failure."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_stop_cameras(device_handle: k4a_device_t);
}
extern "C" {
    #[doc = " Starts the IMU sample stream."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED is returned on success. ::K4A_RESULT_FAILED if the sensor is already running or a failure is"]
    #[doc = " encountered"]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this API to start streaming IMU data. It is not valid to call this function a second time on the same"]
    #[doc = " \\ref k4a_device_t until k4a_device_stop_imu() has been called."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function is dependent on the state of the cameras. The color or depth camera must be started before the IMU."]
    #[doc = " ::K4A_RESULT_FAILED will be returned if one of the cameras is not running."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_start_imu(device_handle: k4a_device_t) -> k4a_result_t;
}
extern "C" {
    #[doc = " Stops the IMU capture."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The streaming of the IMU stops as a result of this call. Once called, k4a_device_start_imu() may"]
    #[doc = " be called again to resume sensor streaming, so long as the cameras are running."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function may be called while another thread is blocking in k4a_device_get_imu_sample()."]
    #[doc = " Calling this function while another thread is in that function will result in that function returning a failure."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_stop_imu(device_handle: k4a_device_t);
}
extern "C" {
    #[doc = " Get the Azure Kinect device serial number."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param serial_number"]
    #[doc = " Location to write the serial number to. If the function returns ::K4A_BUFFER_RESULT_SUCCEEDED, this will be a NULL"]
    #[doc = " terminated string of ASCII characters. If this input is NULL \\p serial_number_size will still be updated to return"]
    #[doc = " the size of the buffer needed to store the string."]
    #[doc = ""]
    #[doc = " \\param serial_number_size"]
    #[doc = " On input, the size of the \\p serial_number buffer if that pointer is not NULL. On output, this value is set to the"]
    #[doc = " actual number of bytes in the serial number (including the null terminator)."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that the \\p serial_number has been filled in. If the buffer is too"]
    #[doc = " small the function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the size of the serial number is"]
    #[doc = " returned in the \\p serial_number_size parameter. All other failures return ::K4A_BUFFER_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Queries the device for its serial number. If the caller needs to know the size of the serial number to allocate"]
    #[doc = " memory, the function should be called once with a NULL \\p serial_number to get the needed size in the \\p"]
    #[doc = " serial_number_size output, and then again with the allocated buffer."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Only a complete serial number will be returned. If the caller's buffer is too small, the function will return"]
    #[doc = " ::K4A_BUFFER_RESULT_TOO_SMALL without returning any data in \\p serial_number."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_serialnum(
        device_handle: k4a_device_t,
        serial_number: *mut ::std::os::raw::c_char,
        serial_number_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Get the version numbers of the device's subsystems."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param version"]
    #[doc = " Location to write the version info to."]
    #[doc = ""]
    #[doc = " \\returns A return of ::K4A_RESULT_SUCCEEDED means that the version structure has been filled in."]
    #[doc = " All other failures return ::K4A_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_version(
        device_handle: k4a_device_t,
        version: *mut k4a_hardware_version_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the Azure Kinect color sensor control capabilities."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param command"]
    #[doc = " Color sensor control command."]
    #[doc = ""]
    #[doc = " \\param supports_auto"]
    #[doc = " Location to store whether the color sensor's control support auto mode or not."]
    #[doc = " true if it supports auto mode, otherwise false."]
    #[doc = ""]
    #[doc = " \\param min_value"]
    #[doc = " Location to store the color sensor's control minimum value of /p command."]
    #[doc = ""]
    #[doc = " \\param max_value"]
    #[doc = " Location to store the color sensor's control maximum value of /p command."]
    #[doc = ""]
    #[doc = " \\param step_value"]
    #[doc = " Location to store the color sensor's control step value of /p command."]
    #[doc = ""]
    #[doc = " \\param default_value"]
    #[doc = " Location to store the color sensor's control default value of /p command."]
    #[doc = ""]
    #[doc = " \\param default_mode"]
    #[doc = " Location to store the color sensor's control default mode of /p command."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if the value was successfully returned, ::K4A_RESULT_FAILED if an error occurred"]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_color_control_capabilities(
        device_handle: k4a_device_t,
        command: k4a_color_control_command_t,
        supports_auto: *mut bool,
        min_value: *mut i32,
        max_value: *mut i32,
        step_value: *mut i32,
        default_value: *mut i32,
        default_mode: *mut k4a_color_control_mode_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the Azure Kinect color sensor control"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param command"]
    #[doc = " Color sensor control command."]
    #[doc = ""]
    #[doc = " \\param mode"]
    #[doc = " Location to store the color sensor's control mode. This mode represents whether the command is in automatic or"]
    #[doc = " manual mode."]
    #[doc = ""]
    #[doc = " \\param value"]
    #[doc = " Location to store the color sensor's control value. This value is always written, but is only valid when the \\p"]
    #[doc = " mode returned is ::K4A_COLOR_CONTROL_MODE_MANUAL for the current \\p command."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if the value was successfully returned, ::K4A_RESULT_FAILED if an error occurred"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Each control command may be set to manual or automatic. See the definition of \\ref k4a_color_control_command_t on"]
    #[doc = " how to interpret the \\p value for each command."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Some control commands are only supported in manual mode. When a command is in automatic mode, the \\p value for"]
    #[doc = " that command is not valid."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Control values set on a device are reset only when the device is power cycled. The device will retain the"]
    #[doc = " settings even if the \\ref k4a_device_t is closed or the application is restarted."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_color_control(
        device_handle: k4a_device_t,
        command: k4a_color_control_command_t,
        mode: *mut k4a_color_control_mode_t,
        value: *mut i32,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Set the Azure Kinect color sensor control value."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param command"]
    #[doc = " Color sensor control command."]
    #[doc = ""]
    #[doc = " \\param mode"]
    #[doc = " Color sensor control mode to set. This mode represents whether the command is in automatic or manual mode."]
    #[doc = ""]
    #[doc = " \\param value"]
    #[doc = " Value to set the color sensor's control to. The value is only valid if \\p mode"]
    #[doc = " is set to ::K4A_COLOR_CONTROL_MODE_MANUAL, and is otherwise ignored."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if the value was successfully set, ::K4A_RESULT_FAILED if an error occurred"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Each control command may be set to manual or automatic. See the definition of \\ref k4a_color_control_command_t on how"]
    #[doc = " to interpret the \\p value for each command."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Some control commands are only supported in manual mode. When a command is in automatic mode, the \\p value for that"]
    #[doc = " command is not valid."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Control values set on a device are reset only when the device is power cycled. The device will retain the settings"]
    #[doc = " even if the \\ref k4a_device_t is closed or the application is restarted."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_set_color_control(
        device_handle: k4a_device_t,
        command: k4a_color_control_command_t,
        mode: k4a_color_control_mode_t,
        value: i32,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the raw calibration blob for the entire Azure Kinect device."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param data"]
    #[doc = " Location to write the calibration data to. This field may optionally be set to NULL for the caller to query for"]
    #[doc = " the needed data size."]
    #[doc = ""]
    #[doc = " \\param data_size"]
    #[doc = " On passing \\p data_size into the function this variable represents the available size of the \\p data"]
    #[doc = " buffer. On return this variable is updated with the amount of data actually written to the buffer, or the size"]
    #[doc = " required to store the calibration buffer if \\p data is NULL."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_BUFFER_RESULT_SUCCEEDED if \\p data was successfully written. If \\p data_size points to a buffer size that is"]
    #[doc = " too small to hold the output or \\p data is NULL, ::K4A_BUFFER_RESULT_TOO_SMALL is returned and \\p data_size is"]
    #[doc = " updated to contain the minimum buffer size needed to capture the calibration data."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_raw_calibration(
        device_handle: k4a_device_t,
        data: *mut u8,
        data_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Get the camera calibration for the entire Azure Kinect device."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param depth_mode"]
    #[doc = " Mode in which depth camera is operated."]
    #[doc = ""]
    #[doc = " \\param color_resolution"]
    #[doc = " Resolution in which color camera is operated."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to write the calibration"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p calibration was successfully written. ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\p calibration represents the data needed to transform between the camera views and may be"]
    #[doc = " different for each operating \\p depth_mode and \\p color_resolution the device is configured to operate in."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\p calibration output is used as input to all calibration and transformation functions."]
    #[doc = ""]
    #[doc = " \\see k4a_calibration_2d_to_2d()"]
    #[doc = " \\see k4a_calibration_2d_to_3d()"]
    #[doc = " \\see k4a_calibration_3d_to_2d()"]
    #[doc = " \\see k4a_calibration_3d_to_3d()"]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_calibration(
        device_handle: k4a_device_t,
        depth_mode: k4a_depth_mode_t,
        color_resolution: k4a_color_resolution_t,
        calibration: *mut k4a_calibration_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the device jack status for the synchronization in and synchronization out connectors."]
    #[doc = ""]
    #[doc = " \\param device_handle"]
    #[doc = " Handle obtained by k4a_device_open()."]
    #[doc = ""]
    #[doc = " \\param sync_in_jack_connected"]
    #[doc = " Upon successful return this value will be set to true if a cable is connected to this sync in jack."]
    #[doc = ""]
    #[doc = " \\param sync_out_jack_connected"]
    #[doc = " Upon successful return this value will be set to true if a cable is connected to this sync out jack."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if the connector status was successfully read."]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p sync_out_jack_connected is true then \\ref k4a_device_configuration_t wired_sync_mode mode can be set to \\ref"]
    #[doc = " K4A_WIRED_SYNC_MODE_STANDALONE or \\ref K4A_WIRED_SYNC_MODE_MASTER. If \\p sync_in_jack_connected is true then \\ref"]
    #[doc = " k4a_device_configuration_t wired_sync_mode mode can be set to \\ref K4A_WIRED_SYNC_MODE_STANDALONE or \\ref"]
    #[doc = " K4A_WIRED_SYNC_MODE_SUBORDINATE."]
    #[doc = ""]
    #[doc = " \\see k4a_device_start_cameras()"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_device_get_sync_jack(
        device_handle: k4a_device_t,
        sync_in_jack_connected: *mut bool,
        sync_out_jack_connected: *mut bool,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the camera calibration for a device from a raw calibration blob."]
    #[doc = ""]
    #[doc = " \\param raw_calibration"]
    #[doc = " Raw calibration blob obtained from a device or recording. The raw calibration must be NULL terminated."]
    #[doc = ""]
    #[doc = " \\param raw_calibration_size"]
    #[doc = " The size, in bytes, of raw_calibration including the NULL termination."]
    #[doc = ""]
    #[doc = " \\param depth_mode"]
    #[doc = " Mode in which depth camera is operated."]
    #[doc = ""]
    #[doc = " \\param color_resolution"]
    #[doc = " Resolution in which color camera is operated."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to write the calibration."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p calibration was successfully written. ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\p calibration represents the data needed to transform between the camera views and is"]
    #[doc = " different for each operating \\p depth_mode and \\p color_resolution the device is configured to operate in."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\p calibration output is used as input to all transformation functions."]
    #[doc = ""]
    #[doc = " \\see k4a_calibration_2d_to_2d()"]
    #[doc = " \\see k4a_calibration_2d_to_3d()"]
    #[doc = " \\see k4a_calibration_3d_to_2d()"]
    #[doc = " \\see k4a_calibration_3d_to_3d()"]
    #[doc = ""]
    #[doc = " \\relates k4a_device_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_calibration_get_from_raw(
        raw_calibration: *mut ::std::os::raw::c_char,
        raw_calibration_size: size_t,
        depth_mode: k4a_depth_mode_t,
        color_resolution: k4a_color_resolution_t,
        calibration: *mut k4a_calibration_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transform a 3D point of a source coordinate system into a 3D point of the target coordinate system"]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to read the camera calibration data."]
    #[doc = ""]
    #[doc = " \\param source_point3d_mm"]
    #[doc = " The 3D coordinates in millimeters representing a point in \\p source_camera."]
    #[doc = ""]
    #[doc = " \\param source_camera"]
    #[doc = " The current camera."]
    #[doc = ""]
    #[doc = " \\param target_camera"]
    #[doc = " The target camera."]
    #[doc = ""]
    #[doc = " \\param target_point3d_mm"]
    #[doc = " Pointer to the output where the new 3D coordinates of the input point in the coordinate space of \\p target_camera is"]
    #[doc = " stored in millimeters."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p target_point3d_mm was successfully written. ::K4A_RESULT_FAILED if \\p calibration"]
    #[doc = " contained invalid transformation parameters."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function is used to transform 3D points between depth and color camera coordinate systems. The function uses the"]
    #[doc = " extrinsic camera calibration. It computes the output via multiplication with a precomputed matrix encoding a 3D"]
    #[doc = " rotation and a 3D translation. If \\p source_camera and \\p target_camera are the same, then \\p target_point3d_mm will"]
    #[doc = " be identical to \\p source_point3d_mm."]
    #[doc = ""]
    #[doc = " \\relates k4a_calibration_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_calibration_3d_to_3d(
        calibration: *const k4a_calibration_t,
        source_point3d_mm: *const k4a_float3_t,
        source_camera: k4a_calibration_type_t,
        target_camera: k4a_calibration_type_t,
        target_point3d_mm: *mut k4a_float3_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transform a 2D pixel coordinate with an associated depth value of the source camera into a 3D point of the target"]
    #[doc = " coordinate system."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to read the camera calibration obtained by k4a_device_get_calibration()."]
    #[doc = ""]
    #[doc = " \\param source_point2d"]
    #[doc = " The 2D pixel in \\p source_camera coordinates."]
    #[doc = ""]
    #[doc = " \\param source_depth_mm"]
    #[doc = " The depth of \\p source_point2d in millimeters. One way to derive the depth value in the color camera geometry is to"]
    #[doc = " use the function k4a_transformation_depth_image_to_color_camera()."]
    #[doc = ""]
    #[doc = " \\param source_camera"]
    #[doc = " The current camera."]
    #[doc = ""]
    #[doc = " \\param target_camera"]
    #[doc = " The target camera."]
    #[doc = ""]
    #[doc = " \\param target_point3d_mm"]
    #[doc = " Pointer to the output where the 3D coordinates of the input pixel in the coordinate system of \\p target_camera is"]
    #[doc = " stored in millimeters."]
    #[doc = ""]
    #[doc = " \\param valid"]
    #[doc = " The output parameter returns a value of 1 if the \\p source_point2d is a valid coordinate, and will return 0 if"]
    #[doc = " the coordinate is not valid in the calibration model."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p target_point3d_mm was successfully written. ::K4A_RESULT_FAILED if \\p calibration"]
    #[doc = " contained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, but \\p valid is 0,"]
    #[doc = " the transformation was computed, but the results in \\p target_point3d_mm are outside of the range of valid"]
    #[doc = " calibration and should be ignored."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function applies the intrinsic calibration of \\p source_camera to compute the 3D ray from the focal point of the"]
    #[doc = " camera through pixel \\p source_point2d. The 3D point on this ray is then found using \\p source_depth_mm. If \\p"]
    #[doc = " target_camera is different from \\p source_camera, the 3D point is transformed to \\p target_camera using"]
    #[doc = " k4a_calibration_3d_to_3d(). In practice, \\p source_camera and \\p target_camera will often be identical. In this"]
    #[doc = " case, no 3D to 3D transformation is applied."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p source_point2d is not considered as valid pixel coordinate"]
    #[doc = " according to the intrinsic camera model, \\p valid is set to 0. If it is valid, \\p valid will be set to 1. The user"]
    #[doc = " should not use the value of \\p target_point3d_mm if \\p valid was set to 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_calibration_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_calibration_2d_to_3d(
        calibration: *const k4a_calibration_t,
        source_point2d: *const k4a_float2_t,
        source_depth_mm: f32,
        source_camera: k4a_calibration_type_t,
        target_camera: k4a_calibration_type_t,
        target_point3d_mm: *mut k4a_float3_t,
        valid: *mut ::std::os::raw::c_int,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transform a 3D point of a source coordinate system into a 2D pixel coordinate of the target camera."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to read the camera calibration obtained by k4a_device_get_calibration()."]
    #[doc = ""]
    #[doc = " \\param source_point3d_mm"]
    #[doc = " The 3D coordinates in millimeters representing a point in \\p source_camera"]
    #[doc = ""]
    #[doc = " \\param source_camera"]
    #[doc = " The current camera."]
    #[doc = ""]
    #[doc = " \\param target_camera"]
    #[doc = " The target camera."]
    #[doc = ""]
    #[doc = " \\param target_point2d"]
    #[doc = " Pointer to the output where the 2D pixel in \\p target_camera coordinates is stored."]
    #[doc = ""]
    #[doc = " \\param valid"]
    #[doc = " The output parameter returns a value of 1 if the \\p source_point3d_mm is a valid coordinate in the \\p target_camera"]
    #[doc = " coordinate system, and will return 0 if the coordinate is not valid in the calibration model."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p target_point2d was successfully written. ::K4A_RESULT_FAILED if \\p calibration"]
    #[doc = " contained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, but \\p valid is 0,"]
    #[doc = " the transformation was computed, but the results in \\p target_point2d are outside of the range of valid calibration"]
    #[doc = " and should be ignored."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p target_camera is different from \\p source_camera, \\p source_point3d_mm is transformed to \\p target_camera using"]
    #[doc = " k4a_calibration_3d_to_3d(). In practice, \\p source_camera and \\p target_camera will often be identical. In this"]
    #[doc = " case, no 3D to 3D transformation is applied. The 3D point in the coordinate system of \\p target_camera is then"]
    #[doc = " projected onto the image plane using the intrinsic calibration of \\p target_camera."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p source_point3d_mm does not map to a valid 2D coordinate in the \\p target_camera coordinate system, \\p valid is"]
    #[doc = " set to 0. If it is valid, \\p valid will be set to 1. The user should not use the value of \\p target_point2d if \\p"]
    #[doc = " valid was set to 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_calibration_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_calibration_3d_to_2d(
        calibration: *const k4a_calibration_t,
        source_point3d_mm: *const k4a_float3_t,
        source_camera: k4a_calibration_type_t,
        target_camera: k4a_calibration_type_t,
        target_point2d: *mut k4a_float2_t,
        valid: *mut ::std::os::raw::c_int,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transform a 2D pixel coordinate with an associated depth value of the source camera into a 2D pixel coordinate of"]
    #[doc = " the target camera."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to read the camera calibration obtained by k4a_device_get_calibration()."]
    #[doc = ""]
    #[doc = " \\param source_point2d"]
    #[doc = " The 2D pixel in \\p source_camera coordinates."]
    #[doc = ""]
    #[doc = " \\param source_depth_mm"]
    #[doc = " The depth of \\p source_point2d in millimeters. One way to derive the depth value in the color camera geometry is to"]
    #[doc = " use the function k4a_transformation_depth_image_to_color_camera()."]
    #[doc = ""]
    #[doc = " \\param source_camera"]
    #[doc = " The current camera."]
    #[doc = ""]
    #[doc = " \\param target_camera"]
    #[doc = " The target camera."]
    #[doc = ""]
    #[doc = " \\param target_point2d"]
    #[doc = " The 2D pixel in \\p target_camera coordinates."]
    #[doc = ""]
    #[doc = " \\param valid"]
    #[doc = " The output parameter returns a value of 1 if the \\p source_point2d is a valid coordinate in the \\p target_camera"]
    #[doc = " coordinate system, and will return 0 if the coordinate is not valid in the calibration model."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p target_point2d was successfully written. ::K4A_RESULT_FAILED if \\p calibration"]
    #[doc = " contained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, but \\p valid is 0,"]
    #[doc = " the transformation was computed, but the results in \\p target_point2d are outside of the range of valid calibration"]
    #[doc = " and should be ignored."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function maps a pixel between the coordinate systems of the depth and color cameras. It is equivalent to calling"]
    #[doc = " k4a_calibration_2d_to_3d() to compute the 3D point corresponding to \\p source_point2d and then using"]
    #[doc = " k4a_calibration_3d_to_2d() to map the 3D point into the coordinate system of the \\p target_camera."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p source_camera and \\p target_camera are identical, the function immediately sets \\p target_point2d to \\p"]
    #[doc = " source_point2d and returns without computing any transformations."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p source_point2d does not map to a valid 2D coordinate in the \\p target_camera coordinate system, \\p valid is set"]
    #[doc = " to 0. If it is valid, \\p valid will be set to 1. The user should not use the value of \\p target_point2d if \\p valid"]
    #[doc = " was set to 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_calibration_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_calibration_2d_to_2d(
        calibration: *const k4a_calibration_t,
        source_point2d: *const k4a_float2_t,
        source_depth_mm: f32,
        source_camera: k4a_calibration_type_t,
        target_camera: k4a_calibration_type_t,
        target_point2d: *mut k4a_float2_t,
        valid: *mut ::std::os::raw::c_int,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transform a 2D pixel coordinate from color camera into a 2D pixel coordinate of"]
    #[doc = " the depth camera."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to read the camera calibration obtained by k4a_device_get_calibration()."]
    #[doc = ""]
    #[doc = " \\param source_point2d"]
    #[doc = " The 2D pixel in \\p color camera coordinates."]
    #[doc = ""]
    #[doc = " \\param depth_image"]
    #[doc = " Handle to input depth image."]
    #[doc = ""]
    #[doc = " \\param target_point2d"]
    #[doc = " The 2D pixel in \\p depth camera coordinates."]
    #[doc = ""]
    #[doc = " \\param valid"]
    #[doc = " The output parameter returns a value of 1 if the \\p source_point2d is a valid coordinate in the \\p target_camera"]
    #[doc = " coordinate system, and will return 0 if the coordinate is not valid in the calibration model."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p target_point2d was successfully written. ::K4A_RESULT_FAILED if \\p calibration"]
    #[doc = " contained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, but \\p valid is 0,"]
    #[doc = " the transformation was computed, but the results in \\p target_point2d are outside of the range of valid calibration"]
    #[doc = " and should be ignored."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function represents an alternative to k4a_calibration_2d_to_2d() if the number of pixels that need to be"]
    #[doc = " transformed is small. This function searches along an epipolar line in the depth image to find the corresponding"]
    #[doc = " depth pixel. If a larger number of pixels need to be transformed, it might be computationally cheaper to call"]
    #[doc = " k4a_transformation_depth_image_to_color_camera() to get correspondence depth values for these color pixels, then call"]
    #[doc = " the function k4a_calibration_2d_to_2d()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If \\p source_point2d does not map to a valid 2D coordinate in the \\p target_camera coordinate system, \\p valid is set"]
    #[doc = " to 0. If it is valid, \\p valid will be set to 1. The user should not use the value of \\p target_point2d if \\p valid"]
    #[doc = " was set to 0."]
    #[doc = ""]
    #[doc = " \\relates k4a_calibration_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_calibration_color_2d_to_depth_2d(
        calibration: *const k4a_calibration_t,
        source_point2d: *const k4a_float2_t,
        depth_image: k4a_image_t,
        target_point2d: *mut k4a_float2_t,
        valid: *mut ::std::os::raw::c_int,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get handle to transformation handle."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " A calibration structure obtained by k4a_device_get_calibration()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A transformation handle. A NULL is returned if creation fails."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The transformation handle is used to transform images from the coordinate system of one camera into the other. Each"]
    #[doc = " transformation handle requires some pre-computed resources to be allocated, which are retained until the handle is"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The transformation handle must be destroyed with k4a_transformation_destroy() when it is no longer to be used."]
    #[doc = ""]
    #[doc = " \\relates k4a_calibration_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_transformation_create(calibration: *const k4a_calibration_t)
        -> k4a_transformation_t;
}
extern "C" {
    #[doc = " Destroy transformation handle."]
    #[doc = ""]
    #[doc = " \\param transformation_handle"]
    #[doc = " Transformation handle to destroy."]
    #[doc = ""]
    #[doc = " \\relates k4a_transformation_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_transformation_destroy(transformation_handle: k4a_transformation_t);
}
extern "C" {
    #[doc = " Transforms the depth map into the geometry of the color camera."]
    #[doc = ""]
    #[doc = " \\param transformation_handle"]
    #[doc = " Transformation handle."]
    #[doc = ""]
    #[doc = " \\param depth_image"]
    #[doc = " Handle to input depth image."]
    #[doc = ""]
    #[doc = " \\param transformed_depth_image"]
    #[doc = " Handle to output transformed depth image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This produces a depth image for which each pixel matches the corresponding pixel coordinates of the color camera."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p depth_image and \\p transformed_depth_image must be of format ::K4A_IMAGE_FORMAT_DEPTH16."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p transformed_depth_image must have a width and height matching the width and height of the color camera in the mode"]
    #[doc = " specified by the \\ref k4a_calibration_t used to create the \\p transformation_handle with k4a_transformation_create()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The contents \\p transformed_depth_image will be filled with the depth values derived from \\p depth_image in the color"]
    #[doc = " camera's coordinate space."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p transformed_depth_image should be created by the caller using k4a_image_create() or"]
    #[doc = " k4a_image_create_from_buffer()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p transformed_depth_image was successfully written and ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\relates k4a_transformation_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_transformation_depth_image_to_color_camera(
        transformation_handle: k4a_transformation_t,
        depth_image: k4a_image_t,
        transformed_depth_image: k4a_image_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transforms depth map and a custom image into the geometry of the color camera."]
    #[doc = ""]
    #[doc = " \\param transformation_handle"]
    #[doc = " Transformation handle."]
    #[doc = ""]
    #[doc = " \\param depth_image"]
    #[doc = " Handle to input depth image."]
    #[doc = ""]
    #[doc = " \\param custom_image"]
    #[doc = " Handle to input custom image."]
    #[doc = ""]
    #[doc = " \\param transformed_depth_image"]
    #[doc = " Handle to output transformed depth image."]
    #[doc = ""]
    #[doc = " \\param transformed_custom_image"]
    #[doc = " Handle to output transformed custom image."]
    #[doc = ""]
    #[doc = " \\param interpolation_type"]
    #[doc = " Parameter that controls how pixels in \\p custom_image should be interpolated when transformed to color camera space."]
    #[doc = " K4A_TRANSFORMATION_INTERPOLATION_TYPE_LINEAR if linear interpolation should be used."]
    #[doc = " K4A_TRANSFORMATION_INTERPOLATION_TYPE_NEAREST if nearest neighbor interpolation should be used."]
    #[doc = ""]
    #[doc = " \\param invalid_custom_value"]
    #[doc = " Defines the custom image pixel value that should be written to \\p transformed_custom_image in case the corresponding"]
    #[doc = " depth pixel can not be transformed into the color camera space."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This produces a depth image and a corresponding custom image for which each pixel matches the corresponding"]
    #[doc = " pixel coordinates of the color camera."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p depth_image and \\p transformed_depth_image must be of format ::K4A_IMAGE_FORMAT_DEPTH16."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p custom_image and \\p transformed_custom_image must be of format ::K4A_IMAGE_FORMAT_CUSTOM8 or"]
    #[doc = " ::K4A_IMAGE_FORMAT_CUSTOM16."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p transformed_depth_image and \\p transformed_custom_image must have a width and height matching the width and"]
    #[doc = " height of the color camera in the mode specified by the \\ref k4a_calibration_t used to create the"]
    #[doc = " \\p transformation_handle with k4a_transformation_create()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p custom_image must have a width and height matching the width and height of \\p depth_image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The contents \\p transformed_depth_image will be filled with the depth values derived from \\p depth_image in the color"]
    #[doc = " camera's coordinate space."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The contents \\p transformed_custom_image will be filled with the values derived from \\p custom_image in the color"]
    #[doc = " camera's coordinate space."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p transformed_depth_image and \\p transformed_custom_image should be created by the caller using k4a_image_create()"]
    #[doc = " or k4a_image_create_from_buffer()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Using ::K4A_TRANSFORMATION_INTERPOLATION_TYPE_LINEAR for \\p interpolation_type could create new values to \\p"]
    #[doc = " transformed_custom_image which do no exist in \\p custom_image. Using ::K4A_TRANSFORMATION_INTERPOLATION_TYPE_NEAREST"]
    #[doc = " will prevent this from happenning but will result in a less smooth image."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p transformed_depth_image and \\p transformed_custom_image were successfully written and"]
    #[doc = " ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\relates k4a_transformation_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_transformation_depth_image_to_color_camera_custom(
        transformation_handle: k4a_transformation_t,
        depth_image: k4a_image_t,
        custom_image: k4a_image_t,
        transformed_depth_image: k4a_image_t,
        transformed_custom_image: k4a_image_t,
        interpolation_type: k4a_transformation_interpolation_type_t,
        invalid_custom_value: u32,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transforms a color image into the geometry of the depth camera."]
    #[doc = ""]
    #[doc = " \\param transformation_handle"]
    #[doc = " Transformation handle."]
    #[doc = ""]
    #[doc = " \\param depth_image"]
    #[doc = " Handle to input depth image."]
    #[doc = ""]
    #[doc = " \\param color_image"]
    #[doc = " Handle to input color image."]
    #[doc = ""]
    #[doc = " \\param transformed_color_image"]
    #[doc = " Handle to output transformed color image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This produces a color image for which each pixel matches the corresponding pixel coordinates of the depth camera."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p depth_image and \\p color_image need to represent the same moment in time. The depth data will be applied to the"]
    #[doc = " color image to properly warp the color data to the perspective of the depth camera."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p depth_image must be of type ::K4A_IMAGE_FORMAT_DEPTH16. \\p color_image must be of format"]
    #[doc = " ::K4A_IMAGE_FORMAT_COLOR_BGRA32."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p transformed_color_image image must be of format ::K4A_IMAGE_FORMAT_COLOR_BGRA32. \\p transformed_color_image must"]
    #[doc = " have the width and height of the depth camera in the mode specified by the \\ref k4a_calibration_t used to create"]
    #[doc = " the \\p transformation_handle with k4a_transformation_create()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p transformed_color_image should be created by the caller using k4a_image_create() or"]
    #[doc = " k4a_image_create_from_buffer()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p transformed_color_image was successfully written and ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\relates k4a_transformation_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_transformation_color_image_to_depth_camera(
        transformation_handle: k4a_transformation_t,
        depth_image: k4a_image_t,
        color_image: k4a_image_t,
        transformed_color_image: k4a_image_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Transforms the depth image into 3 planar images representing X, Y and Z-coordinates of corresponding 3D points."]
    #[doc = ""]
    #[doc = " \\param transformation_handle"]
    #[doc = " Transformation handle."]
    #[doc = ""]
    #[doc = " \\param depth_image"]
    #[doc = " Handle to input depth image."]
    #[doc = ""]
    #[doc = " \\param camera"]
    #[doc = " Geometry in which depth map was computed."]
    #[doc = ""]
    #[doc = " \\param xyz_image"]
    #[doc = " Handle to output xyz image."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p depth_image must be of format ::K4A_IMAGE_FORMAT_DEPTH16."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The \\p camera parameter tells the function what the perspective of the \\p depth_image is. If the \\p depth_image was"]
    #[doc = " captured directly from the depth camera, the value should be ::K4A_CALIBRATION_TYPE_DEPTH. If the \\p depth_image is"]
    #[doc = " the result of a transformation into the color camera's coordinate space using"]
    #[doc = " k4a_transformation_depth_image_to_color_camera(), the value should be ::K4A_CALIBRATION_TYPE_COLOR."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The format of \\p xyz_image must be ::K4A_IMAGE_FORMAT_CUSTOM. The width and height of \\p xyz_image must match the"]
    #[doc = " width and height of \\p depth_image. \\p xyz_image must have a stride in bytes of at least 6 times its width in pixels."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Each pixel of the \\p xyz_image consists of three int16_t values, totaling 6 bytes. The three int16_t values are the"]
    #[doc = " X, Y, and Z values of the point."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " \\p xyz_image should be created by the caller using k4a_image_create() or k4a_image_create_from_buffer()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p xyz_image was successfully written and ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\relates k4a_transformation_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4a.h (include k4a/k4a.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4a.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4a.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_transformation_depth_image_to_point_cloud(
        transformation_handle: k4a_transformation_t,
        depth_image: k4a_image_t,
        camera: k4a_calibration_type_t,
        xyz_image: k4a_image_t,
    ) -> k4a_result_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_record_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_record_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_record_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_record_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_record_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_record_t = *mut _k4a_record_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_playback_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_playback_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_playback_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_playback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_playback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_playback_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_playback_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_playback_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_playback_t = *mut _k4a_playback_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_playback_data_block_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_playback_data_block_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_playback_data_block_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_playback_data_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_playback_data_block_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_playback_data_block_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_playback_data_block_t>()))._rsvd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_playback_data_block_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_playback_data_block_t = *mut _k4a_playback_data_block_t;
#[doc = "< The result was successful."]
pub const k4a_stream_result_t_K4A_STREAM_RESULT_SUCCEEDED: k4a_stream_result_t = 0;
#[doc = "< The result was a failure."]
pub const k4a_stream_result_t_K4A_STREAM_RESULT_FAILED: k4a_stream_result_t = 1;
#[doc = "< The end of the data stream was reached."]
pub const k4a_stream_result_t_K4A_STREAM_RESULT_EOF: k4a_stream_result_t = 2;
#[doc = " Return codes returned by Azure Kinect playback API."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_stream_result_t = ::std::os::raw::c_uint;
#[doc = "< Seek relative to the beginning of a recording."]
pub const k4a_playback_seek_origin_t_K4A_PLAYBACK_SEEK_BEGIN: k4a_playback_seek_origin_t = 0;
#[doc = "< Seek relative to the end of a recording."]
pub const k4a_playback_seek_origin_t_K4A_PLAYBACK_SEEK_END: k4a_playback_seek_origin_t = 1;
#[doc = "< Seek to an absolute device timestamp."]
pub const k4a_playback_seek_origin_t_K4A_PLAYBACK_SEEK_DEVICE_TIME: k4a_playback_seek_origin_t = 2;
#[doc = " Playback seeking positions."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_playback_seek_origin_t = ::std::os::raw::c_uint;
#[doc = " Structure containing the device configuration used to record."]
#[doc = ""]
#[doc = " \\see k4a_device_configuration_t"]
#[doc = " \\see k4a_playback_get_record_configuration()"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_record_configuration_t {
    #[doc = " Image format used to record the color camera."]
    pub color_format: k4a_image_format_t,
    #[doc = " Image resolution used to record the color camera."]
    pub color_resolution: k4a_color_resolution_t,
    #[doc = " Mode used to record the depth camera."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = " Frame rate used to record the color and depth camera."]
    pub camera_fps: k4a_fps_t,
    #[doc = " True if the recording contains Color camera frames."]
    pub color_track_enabled: bool,
    #[doc = " True if the recording contains Depth camera frames."]
    pub depth_track_enabled: bool,
    #[doc = " True if the recording contains IR camera frames."]
    pub ir_track_enabled: bool,
    #[doc = " True if the recording contains IMU sample data."]
    pub imu_track_enabled: bool,
    #[doc = " The delay between color and depth images in the recording."]
    #[doc = " A negative delay means depth images are first, and a positive delay means color images are first."]
    pub depth_delay_off_color_usec: i32,
    #[doc = " External synchronization mode"]
    pub wired_sync_mode: k4a_wired_sync_mode_t,
    #[doc = " The delay between this recording and the externally synced master camera."]
    #[doc = " This value is 0 unless \\p wired_sync_mode is set to ::K4A_WIRED_SYNC_MODE_SUBORDINATE"]
    pub subordinate_delay_off_master_usec: u32,
    #[doc = " The timestamp offset of the start of the recording. All recorded timestamps are offset by this value such that"]
    #[doc = " the recording starts at timestamp 0. This value can be used to synchronize timestamps between 2 recording files."]
    pub start_timestamp_offset_usec: u32,
}
#[test]
fn bindgen_test_layout__k4a_record_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_configuration_t>(),
        36usize,
        concat!("Size of: ", stringify!(_k4a_record_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_configuration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_record_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).color_format as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).color_resolution as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(color_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).depth_mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).camera_fps as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(camera_fps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).color_track_enabled as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(color_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).depth_track_enabled as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(depth_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).ir_track_enabled as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(ir_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).imu_track_enabled as *const _
                as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(imu_track_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).depth_delay_off_color_usec
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(depth_delay_off_color_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).wired_sync_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(wired_sync_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>()))
                .subordinate_delay_off_master_usec as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(subordinate_delay_off_master_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_configuration_t>())).start_timestamp_offset_usec
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_configuration_t),
            "::",
            stringify!(start_timestamp_offset_usec)
        )
    );
}
impl Default for _k4a_record_configuration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure containing the device configuration used to record."]
#[doc = ""]
#[doc = " \\see k4a_device_configuration_t"]
#[doc = " \\see k4a_playback_get_record_configuration()"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_record_configuration_t = _k4a_record_configuration_t;
#[doc = " Structure containing additional metadata specific to custom video tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_record_video_settings_t {
    #[doc = "< Frame width of the video"]
    pub width: u64,
    #[doc = "< Frame height of the video"]
    pub height: u64,
    #[doc = "< Frame rate (frames-per-second) of the video"]
    pub frame_rate: u64,
}
#[test]
fn bindgen_test_layout__k4a_record_video_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_video_settings_t>(),
        24usize,
        concat!("Size of: ", stringify!(_k4a_record_video_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_video_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_record_video_settings_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_video_settings_t>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_video_settings_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_video_settings_t>())).height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_video_settings_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_video_settings_t>())).frame_rate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_video_settings_t),
            "::",
            stringify!(frame_rate)
        )
    );
}
#[doc = " Structure containing additional metadata specific to custom video tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_record_video_settings_t = _k4a_record_video_settings_t;
#[doc = " Structure containing additional metadata specific to custom subtitle tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _k4a_record_subtitle_settings_t {
    #[doc = " If true, data will be grouped together in batches to reduce overhead. In this mode, only a single timestamp will"]
    #[doc = " be stored per batch, and an estimated timestamp will be used by k4a_playback_seek_timestamp() and"]
    #[doc = " k4a_playback_data_block_get_timestamp_usec(). The estimated timestamp is calculated with the assumption that"]
    #[doc = " blocks are evenly spaced within a batch. If precise timestamps are required, the timestamp should be added to"]
    #[doc = " each data block itself."]
    #[doc = ""]
    #[doc = " If false, data will be stored as individual blocks with full timestamp information (Default)."]
    pub high_freq_data: bool,
}
#[test]
fn bindgen_test_layout__k4a_record_subtitle_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_record_subtitle_settings_t>(),
        1usize,
        concat!("Size of: ", stringify!(_k4a_record_subtitle_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_record_subtitle_settings_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_k4a_record_subtitle_settings_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_record_subtitle_settings_t>())).high_freq_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_record_subtitle_settings_t),
            "::",
            stringify!(high_freq_data)
        )
    );
}
#[doc = " Structure containing additional metadata specific to custom subtitle tracks."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">types.h (include k4arecord/types.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_record_subtitle_settings_t = _k4a_record_subtitle_settings_t;
extern "C" {
    #[doc = " Opens a new recording file for writing."]
    #[doc = ""]
    #[doc = " \\param path"]
    #[doc = " Filesystem path for the new recording."]
    #[doc = ""]
    #[doc = " \\param device"]
    #[doc = " The Azure Kinect device that is being recorded. The device handle is used to store device calibration and serial"]
    #[doc = " number information. May be NULL if recording user-generated data."]
    #[doc = ""]
    #[doc = " \\param device_config"]
    #[doc = " The configuration the Azure Kinect device was started with."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " If successful, this contains a pointer to the new recording handle. Caller must call k4a_record_close()"]
    #[doc = " when finished with recording."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The file will be created if it doesn't exist, or overwritten if an existing file is specified."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Streaming does not need to be started on the device at the time this function is called, but when it is started"]
    #[doc = " it should be started with the same configuration provided in \\p device_config."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Subsequent calls to k4a_record_write_capture() will need to have images in the resolution and format defined"]
    #[doc = " in \\p device_config."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_create(
        path: *const ::std::os::raw::c_char,
        device: k4a_device_t,
        device_config: k4a_device_configuration_t,
        recording_handle: *mut k4a_record_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Adds a tag to the recording."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param name"]
    #[doc = " The name of the tag to write."]
    #[doc = ""]
    #[doc = " \\param value"]
    #[doc = " The string value to store in the tag."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Tags are global to a file, and should store data related to the entire recording, such as camera configuration or"]
    #[doc = " recording location."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Tag names must be ALL CAPS and may only contain A-Z, 0-9, '-' and '_'."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " All tags need to be added before the recording header is written."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_add_tag(
        recording_handle: k4a_record_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Adds the track header for recording IMU."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The track needs to be added before the recording header is written."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_add_imu_track(recording_handle: k4a_record_t) -> k4a_result_t;
}
extern "C" {
    #[doc = " Adds an attachment to the recording."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param attachment_name"]
    #[doc = " The name of the attachment to be stored in the recording file. This name should be a valid filename with an"]
    #[doc = " extension."]
    #[doc = ""]
    #[doc = " \\param buffer"]
    #[doc = " The attachment data buffer."]
    #[doc = ""]
    #[doc = " \\param buffer_size"]
    #[doc = " The size of the attachment data buffer."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " All attachments need to be added before the recording header is written."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_add_attachment(
        recording_handle: k4a_record_t,
        attachment_name: *const ::std::os::raw::c_char,
        buffer: *const u8,
        buffer_size: size_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Adds custom video tracks to the recording."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The name of the custom video track to be added."]
    #[doc = ""]
    #[doc = " \\param codec_id"]
    #[doc = " A UTF8 null terminated string containing the codec ID of the track. Some of the existing formats are listed here:"]
    #[doc = " https://www.matroska.org/technical/specs/codecid/index.html. The codec ID can also be custom defined by the user."]
    #[doc = " Video codec ID's should start with 'V_'."]
    #[doc = ""]
    #[doc = " \\param codec_context"]
    #[doc = " The codec context is a codec-specific buffer that contains any required codec metadata that is only known to the"]
    #[doc = " codec. It is mapped to the matroska 'CodecPrivate' element."]
    #[doc = ""]
    #[doc = " \\param codec_context_size"]
    #[doc = " The size of the codec context buffer."]
    #[doc = ""]
    #[doc = " \\param track_settings"]
    #[doc = " Additional metadata for the video track such as resolution and framerate."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Built-in video tracks like the DEPTH, IR, and COLOR tracks will be created automatically when the k4a_record_create()"]
    #[doc = " API is called. This API can be used to add additional video tracks to save custom data."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Track names must be ALL CAPS and may only contain A-Z, 0-9, '-' and '_'."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " All tracks need to be added before the recording header is written."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call k4a_record_write_custom_track_data() with the same track_name to write data to this track."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_add_custom_video_track(
        recording_handle: k4a_record_t,
        track_name: *const ::std::os::raw::c_char,
        codec_id: *const ::std::os::raw::c_char,
        codec_context: *const u8,
        codec_context_size: size_t,
        track_settings: *const k4a_record_video_settings_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Adds custom subtitle tracks to the recording."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The name of the custom subtitle track to be added."]
    #[doc = ""]
    #[doc = " \\param codec_id"]
    #[doc = " A UTF8 null terminated string containing the codec ID of the track. Some of the existing formats are listed here:"]
    #[doc = " https://www.matroska.org/technical/specs/codecid/index.html. The codec ID can also be custom defined by the user."]
    #[doc = " Subtitle codec ID's should start with 'S_'."]
    #[doc = ""]
    #[doc = " \\param codec_context"]
    #[doc = " The codec context is a codec-specific buffer that contains any required codec metadata that is only known to the"]
    #[doc = " codec. It is mapped to the matroska 'CodecPrivate' element."]
    #[doc = ""]
    #[doc = " \\param codec_context_size"]
    #[doc = " The size of the codec context buffer."]
    #[doc = ""]
    #[doc = " \\param track_settings"]
    #[doc = " Additional metadata for the subtitle track. If NULL, the default settings will be used."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Built-in subtitle tracks like the IMU track will be created automatically when the k4a_record_add_imu_track() API is"]
    #[doc = " called. This API can be used to add additional subtitle tracks to save custom data."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Track names must be ALL CAPS and may only contain A-Z, 0-9, '-' and '_'."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " All tracks need to be added before the recording header is written."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call k4a_record_write_custom_track_data() with the same track_name to write data to this track."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_add_custom_subtitle_track(
        recording_handle: k4a_record_t,
        track_name: *const ::std::os::raw::c_char,
        codec_id: *const ::std::os::raw::c_char,
        codec_context: *const u8,
        codec_context_size: size_t,
        track_settings: *const k4a_record_subtitle_settings_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Writes the recording header and metadata to file."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This must be called before captures or any track data can be written."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_write_header(recording_handle: k4a_record_t) -> k4a_result_t;
}
extern "C" {
    #[doc = " Writes a camera capture to file."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " The handle of a capture to write to file."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Captures must be written in increasing order of timestamp, and the file's header must already be written."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_record_write_capture() will write all images in the capture to the corresponding tracks in the recording file."]
    #[doc = " If any of the images fail to write, other images will still be written before a failure is returned."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_write_capture(
        recording_handle: k4a_record_t,
        capture_handle: k4a_capture_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Writes an imu sample to file."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param imu_sample"]
    #[doc = " A structure containing the imu sample data and timestamps."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Samples must be written in increasing order of timestamp, and the file's header must already be written."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When writing imu samples at the same time as captures, the samples should be within 1 second of the most recently"]
    #[doc = " written capture."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_write_imu_sample(
        recording_handle: k4a_record_t,
        imu_sample: k4a_imu_sample_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Writes data for a custom track to file."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " The handle of a new recording, obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The name of the custom track that the data is going to be written to."]
    #[doc = ""]
    #[doc = " \\param device_timestamp_usec"]
    #[doc = " The timestamp in microseconds for the custom track data. This timestamp should be in the same time domain as the"]
    #[doc = " device timestamp used for recording."]
    #[doc = ""]
    #[doc = " \\param custom_data"]
    #[doc = " The buffer of custom track data."]
    #[doc = ""]
    #[doc = " \\param custom_data_size"]
    #[doc = " The size of the custom track data buffer."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Custom track data must be written in increasing order of timestamp, and the file's header must already be written."]
    #[doc = " When writing custom track data at the same time as captures or IMU data, the custom data should be within 1 second of"]
    #[doc = " the most recently written timestamp."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_write_custom_track_data(
        recording_handle: k4a_record_t,
        track_name: *const ::std::os::raw::c_char,
        device_timestamp_usec: u64,
        custom_data: *mut u8,
        custom_data_size: size_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Flushes all pending recording data to disk."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " Handle obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success, or ::K4A_RESULT_FAILED if an error occurred."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_record_flush() ensures that all data passed to the recording API prior to calling flush is written to disk."]
    #[doc = " If continuing to write recording data, care must be taken to ensure no new timestamps are added from before the"]
    #[doc = " flush."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If an error occurs, best effort is made to flush as much data to disk as possible, but the integrity of the file is"]
    #[doc = " not guaranteed."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_flush(recording_handle: k4a_record_t) -> k4a_result_t;
}
extern "C" {
    #[doc = " Closes a recording handle."]
    #[doc = ""]
    #[doc = " \\param recording_handle"]
    #[doc = " Handle obtained by k4a_record_create()."]
    #[doc = ""]
    #[doc = " \\headerfile record.h <k4arecord/record.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_record_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If there is any unwritten data it will be flushed to disk before closing the recording."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">record.h (include k4arecord/record.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_record_close(recording_handle: k4a_record_t);
}
extern "C" {
    #[doc = " Opens an existing recording file for reading."]
    #[doc = ""]
    #[doc = " \\param path"]
    #[doc = " Filesystem path of the existing recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " If successful, this contains a pointer to the recording handle. Caller must call k4a_playback_close() when"]
    #[doc = " finished with the recording."]
    #[doc = ""]
    #[doc = " \\headerfile playback.h <k4arecord/playback.h>"]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success"]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_open(
        path: *const ::std::os::raw::c_char,
        playback_handle: *mut k4a_playback_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the raw calibration blob for the Azure Kinect device used during recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param data"]
    #[doc = " Location to write the calibration data to. This field may optionally be set to NULL if the caller wants to query for"]
    #[doc = " the needed data size."]
    #[doc = ""]
    #[doc = " \\param data_size"]
    #[doc = " On passing \\p data_size into the function this variable represents the available size to write the raw data to. On"]
    #[doc = " return this variable is updated with the amount of data actually written to the buffer."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_BUFFER_RESULT_SUCCEEDED if \\p data was successfully written. If \\p data_size points to a buffer size that is"]
    #[doc = " too small to hold the output, ::K4A_BUFFER_RESULT_TOO_SMALL is returned and \\p data_size is updated to contain the"]
    #[doc = " minimum buffer size needed to capture the calibration data."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The raw calibration may not exist if the device was not specified during recording."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_raw_calibration(
        playback_handle: k4a_playback_t,
        data: *mut u8,
        data_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Get the camera calibration for Azure Kinect device used during recording. The output struct is used as input to all"]
    #[doc = " transformation functions."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param calibration"]
    #[doc = " Location to write the calibration."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p calibration was successfully written. ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The calibration may not exist if the device was not specified during recording."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_calibration(
        playback_handle: k4a_playback_t,
        calibration: *mut k4a_calibration_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the device configuration used during recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param config"]
    #[doc = " Location to write the recording configuration."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if \\p config was successfully written. ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_record_configuration(
        playback_handle: k4a_playback_t,
        config: *mut k4a_record_configuration_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Checks whether a track with the given track name exists in the playback file."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The track name to be checked to see whether it exists or not."]
    #[doc = ""]
    #[doc = " \\returns true if the track exists."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_check_track_exists(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the number of tracks in a playback file."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\returns the number of tracks in the playback file."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_track_count(playback_handle: k4a_playback_t) -> size_t;
}
extern "C" {
    #[doc = " Gets the name of a track at a specific index."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_index"]
    #[doc = " The index of the track to read the name form."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " Location to write the track name. This will be a UTF8 null terminated string. If a NULL buffer is specified,"]
    #[doc = " \\p track_name_size will be set to the size of buffer needed to store the string."]
    #[doc = ""]
    #[doc = " \\param track_name_size"]
    #[doc = " On input, the size of the \\p track_name buffer. On output, this is set to the length of the track_name value"]
    #[doc = " (including the null terminator)."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that the \\p track_name has been filled in. If the buffer is too small"]
    #[doc = " the function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the needed size of the \\p track_name buffer is returned in the"]
    #[doc = " \\p track_name_size parameter. ::K4A_BUFFER_RESULT_FAILED is returned if the track index does not exist. All other"]
    #[doc = " failures return ::K4A_BUFFER_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When used along with k4a_playback_get_track_count(), this function can be used to enumerate all the available tracks"]
    #[doc = " in a playback file. Additionally k4a_playback_track_is_builtin() can be used to filter custom tracks."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_track_name(
        playback_handle: k4a_playback_t,
        track_index: size_t,
        track_name: *mut ::std::os::raw::c_char,
        track_name_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Checks whether a track is one of the built-in tracks: \"COLOR\", \"DEPTH\", etc..."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The track name to be checked to see whether it is a built-in track."]
    #[doc = ""]
    #[doc = " \\returns true if the track is built-in. If the provided track name does not exist, false will be returned."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_track_is_builtin(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the video-specific track information for a particular video track."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The track name to read video settings from."]
    #[doc = ""]
    #[doc = " \\param video_settings"]
    #[doc = " Location to write the track's video settings."]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED is returned on success, ::K4A_RESULT_FAILED is returned if the specified track does"]
    #[doc = " not exist or is not a video track."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_track_get_video_settings(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        video_settings: *mut k4a_record_video_settings_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Gets the codec id string for a particular track."]
    #[doc = ""]
    #[doc = " The codec ID is a string that corresponds to the codec of the track's data. Some of the existing formats are listed"]
    #[doc = " here: https://www.matroska.org/technical/specs/codecid/index.html. It can also be custom defined by the user."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The track name to read the codec id from."]
    #[doc = ""]
    #[doc = " \\param codec_id"]
    #[doc = " Location to write the codec id. This will be a UTF8 null terminated string. If a NULL buffer is specified,"]
    #[doc = " \\p codec_id_size will be set to the size of buffer needed to store the string."]
    #[doc = ""]
    #[doc = " \\param codec_id_size"]
    #[doc = " On input, the size of the \\p codec_id buffer. On output, this is set to the length of the codec_id value (including"]
    #[doc = " the null terminator)."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that the \\p codec_id has been filled in. If the buffer is too small"]
    #[doc = " the function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the needed size of the \\p codec_id buffer is returned in the"]
    #[doc = " \\p codec_id_size parameter. ::K4A_BUFFER_RESULT_FAILED is returned if the track_name does not exist. All other"]
    #[doc = " failures return ::K4A_BUFFER_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_track_get_codec_id(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        codec_id: *mut ::std::os::raw::c_char,
        codec_id_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Gets the codec context for a particular track."]
    #[doc = ""]
    #[doc = " The codec context is a codec-specific buffer that contains any required codec metadata that is only known to the"]
    #[doc = " codec. It is mapped to the matroska Codec Private field."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The track name to read the codec context from."]
    #[doc = ""]
    #[doc = " \\param codec_context"]
    #[doc = " Location to write the codec context data. If a NULL buffer is specified, \\p codec_context_size will be set to the"]
    #[doc = " size of buffer needed to store the data."]
    #[doc = ""]
    #[doc = " \\param codec_context_size"]
    #[doc = " On input, the size of the \\p codec_context buffer. On output, this is set to the length of the codec_context data."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that the \\p codec_context has been filled in. If the buffer is too"]
    #[doc = " small the function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the needed size of the \\p codec_context buffer is"]
    #[doc = " returned in the \\p codec_context_size parameter. ::K4A_BUFFER_RESULT_FAILED is returned if the track_name does not"]
    #[doc = " exist. All other failures return ::K4A_BUFFER_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_track_get_codec_context(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        codec_context: *mut u8,
        codec_context_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Read the value of a tag from a recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param name"]
    #[doc = " The name of the tag to read."]
    #[doc = ""]
    #[doc = " \\param value"]
    #[doc = " Location to write the tag value. This will be a UTF8 null terminated string. If a NULL buffer is specified,"]
    #[doc = " \\p value_size will be set to the size of buffer needed to store the string."]
    #[doc = ""]
    #[doc = " \\param value_size"]
    #[doc = " On input, the size of the \\p value buffer. On output, this is set to the length of the tag value (including the null"]
    #[doc = " terminator)."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that the \\p value has been filled in. If the buffer is too small the"]
    #[doc = " function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the needed size of the \\p value buffer is returned in the"]
    #[doc = " \\p value_size parameter. ::K4A_BUFFER_RESULT_FAILED is returned if the tag does not exist. All other failures return"]
    #[doc = " ::K4A_BUFFER_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Tags are global to a file, and should store data related to the entire recording, such as camera configuration or"]
    #[doc = " recording location."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_tag(
        playback_handle: k4a_playback_t,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        value_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Set the image format that color captures will be converted to. By default the conversion format will be the same as"]
    #[doc = " the image format stored in the recording file, and no conversion will occur."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param target_format"]
    #[doc = " The target image format to be returned in captures."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if the format conversion is supported. ::K4A_RESULT_FAILED otherwise."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " After the color conversion format is set, all \\ref k4a_capture_t objects returned from the playback handle will have"]
    #[doc = " their color images converted to the \\p target_format."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Color format conversion occurs in the user-thread, so setting \\p target_format to anything other than the format"]
    #[doc = " stored in the file may significantly increase the latency of \\p k4a_playback_get_next_capture() and"]
    #[doc = " \\p k4a_playback_get_previous_capture()."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_set_color_conversion(
        playback_handle: k4a_playback_t,
        target_format: k4a_image_format_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Reads an attachment file from a recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param file_name"]
    #[doc = " The attachment file name."]
    #[doc = ""]
    #[doc = " \\param data"]
    #[doc = " Location to write the attachment data. If a NULL buffer is specified, \\p data_size will be set to the size of"]
    #[doc = " buffer needed to store the data."]
    #[doc = ""]
    #[doc = " \\param data_size"]
    #[doc = " On input, the size of the \\p data buffer. On output, this is set to the length of the attachment data."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that the \\p data has been filled in. If the buffer is too small the"]
    #[doc = " function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the needed size of the \\p data buffer is returned in the"]
    #[doc = " \\p data_size parameter. ::K4A_BUFFER_RESULT_FAILED is returned if the attachment \\p file_name does not exist. All"]
    #[doc = " other failures return ::K4A_BUFFER_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_attachment(
        playback_handle: k4a_playback_t,
        file_name: *const ::std::os::raw::c_char,
        data: *mut u8,
        data_size: *mut size_t,
    ) -> k4a_buffer_result_t;
}
extern "C" {
    #[doc = " Read the next capture in the recording sequence."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " If successful this contains a handle to a capture object. Caller must call k4a_capture_release() when its done using"]
    #[doc = " this capture"]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_STREAM_RESULT_SUCCEEDED if a capture is returned, or ::K4A_STREAM_RESULT_EOF if the end of the recording is"]
    #[doc = " reached. All other failures will return ::K4A_STREAM_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_next_capture() always returns the next capture in sequence after the most recently returned capture."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_next_capture() after k4a_playback_seek_timestamp() will return the capture"]
    #[doc = " in the recording closest to the seek time with an image timestamp greater than or equal to the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If a call was made to k4a_playback_get_previous_capture() that returned ::K4A_STREAM_RESULT_EOF, the playback"]
    #[doc = " position is at the beginning of the stream and k4a_playback_get_next_capture() will return the first capture in the"]
    #[doc = " recording."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Capture objects returned by the playback API will always contain at least one image, but may have images missing if"]
    #[doc = " frames were dropped in the original recording. When calling k4a_capture_get_color_image(),"]
    #[doc = " k4a_capture_get_depth_image(), or k4a_capture_get_ir_image(), the image should be checked for NULL."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_next_capture(
        playback_handle: k4a_playback_t,
        capture_handle: *mut k4a_capture_t,
    ) -> k4a_stream_result_t;
}
extern "C" {
    #[doc = " Read the previous capture in the recording sequence."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param capture_handle"]
    #[doc = " If successful this contains a handle to a capture object. Caller must call k4a_capture_release() when its done using"]
    #[doc = " this capture."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_STREAM_RESULT_SUCCEEDED if a capture is returned, or ::K4A_STREAM_RESULT_EOF if the start of the recording is"]
    #[doc = " reached. All other failures will return ::K4A_STREAM_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_previous_capture() always returns the previous capture in the sequence before the most"]
    #[doc = " recently returned capture."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If a call was made to k4a_playback_get_next_capture() that returned ::K4A_STREAM_RESULT_EOF, the playback position"]
    #[doc = " is at the end of the stream and k4a_playback_get_previous_capture() will return the last capture in"]
    #[doc = " the recording."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_previous_capture() after k4a_playback_seek_timestamp() will return the"]
    #[doc = " capture in the recording closest to the seek time with all image timestamps less than the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Capture objects returned by this API will always contain at least one image, but may have images missing if frames"]
    #[doc = " were dropped in the original recording. When calling k4a_capture_get_color_image(), k4a_capture_get_depth_image(), or"]
    #[doc = " k4a_capture_get_ir_image(), the image should be checked for NULL."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_previous_capture(
        playback_handle: k4a_playback_t,
        capture_handle: *mut k4a_capture_t,
    ) -> k4a_stream_result_t;
}
extern "C" {
    #[doc = " Read the next IMU sample in the recording sequence."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param imu_sample"]
    #[doc = " The location to write the IMU sample."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_STREAM_RESULT_SUCCEEDED if a sample is returned, or ::K4A_STREAM_RESULT_EOF if the end of the recording is"]
    #[doc = " reached. All other failures will return ::K4A_STREAM_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_next_imu_sample() always returns the IMU sample after the most recently returned sample."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If a call was made to k4a_playback_get_previous_imu_sample() which returned ::K4A_STREAM_RESULT_EOF, then the"]
    #[doc = " playback position is at the beginning of the recording and k4a_playback_get_next_imu_sample() will return the first"]
    #[doc = " IMU sample in the recording."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_next_imu_sample() after k4a_playback_seek_timestamp() will return the IMU"]
    #[doc = " sample in the recording closest to the seek time with a timestamp greater than or equal to the seek time."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_next_imu_sample(
        playback_handle: k4a_playback_t,
        imu_sample: *mut k4a_imu_sample_t,
    ) -> k4a_stream_result_t;
}
extern "C" {
    #[doc = " Read the previous IMU sample in the recording sequence."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param imu_sample [OUT]"]
    #[doc = " The location to write the IMU sample."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_STREAM_RESULT_SUCCEEDED if a sample is returned, or ::K4A_STREAM_RESULT_EOF if the start of the recording is"]
    #[doc = " reached. All other failures will return ::K4A_STREAM_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_previous_imu_sample() always returns the IMU sample before the most recently returned sample."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If a call was made to to k4a_playback_get_next_imu_sample() which returned ::K4A_STREAM_RESULT_EOF, then the playback"]
    #[doc = " position is at the end of the recording and k4a_playback_get_previous_imu_sample() will return the last IMU sample in"]
    #[doc = " the recording."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_previous_imu_sample() after k4a_playback_seek_timestamp() will return the"]
    #[doc = " IMU sample closest to the seek time with a timestamp less than the seek time."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_previous_imu_sample(
        playback_handle: k4a_playback_t,
        imu_sample: *mut k4a_imu_sample_t,
    ) -> k4a_stream_result_t;
}
extern "C" {
    #[doc = " Read the next data block for a particular track."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The name of the track to read the next data block from."]
    #[doc = ""]
    #[doc = " \\param data_block_handle"]
    #[doc = " The location to write the data block handle."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_STREAM_RESULT_SUCCEEDED if a data block is returned, or ::K4A_STREAM_RESULT_EOF if the end of the recording is"]
    #[doc = " reached. All other failures will return ::K4A_STREAM_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_next_data_block() always returns the data block after the most recently returned data block for a"]
    #[doc = " particular track."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If a call was made to k4a_playback_get_previous_data_block() which returned ::K4A_STREAM_RESULT_EOF, then the"]
    #[doc = " playback position is at the beginning of the recording and calling k4a_playback_get_next_data_block() with the same"]
    #[doc = " track will return the first data block in the track."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_next_data_block() after k4a_playback_seek_timestamp() will return the data"]
    #[doc = " block in the recording closest to the seek time with a timestamp greater than or equal to the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_next_data_block() cannot be used with the built-in tracks: \"COLOR\", \"DEPTH\", etc..."]
    #[doc = " k4a_playback_track_is_builtin() can be used to determine if a track is a built-in track."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If the call is successful, callers must call k4a_playback_data_block_release() to return the allocated memory for"]
    #[doc = " data_block_handle."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_next_data_block(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        data_block_handle: *mut k4a_playback_data_block_t,
    ) -> k4a_stream_result_t;
}
extern "C" {
    #[doc = " Read the previous data block for a particular track."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param track_name"]
    #[doc = " The name of the track to read the previous data block from."]
    #[doc = ""]
    #[doc = " \\param data_block_handle"]
    #[doc = " The location to write the data block."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_STREAM_RESULT_SUCCEEDED if a sample is returned, or ::K4A_STREAM_RESULT_EOF if the start of the recording is"]
    #[doc = " reached. All other failures will return ::K4A_STREAM_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_previous_data_block() always returns the data block before the most recently returned data block for"]
    #[doc = " a particular track."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If a call was made to to k4a_playback_get_next_data_block() which returned ::K4A_STREAM_RESULT_EOF, then the playback"]
    #[doc = " position is at the end of the recording and calling k4a_playback_get_previous_data_block() with the same track will"]
    #[doc = " return the last data block in the track."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_previous_data_block() after k4a_playback_seek_timestamp() will return the"]
    #[doc = " data block closest to the seek time with a timestamp less than the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If the call is successful, callers must call k4a_playback_data_block_release() to return the allocated memory for"]
    #[doc = " data_block_handle."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " k4a_playback_get_previous_data_block() cannot be used with the built-in tracks: \"COLOR\", \"DEPTH\", etc..."]
    #[doc = " k4a_playback_track_is_builtin() can be used to determine if a track is a built-in track."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_previous_data_block(
        playback_handle: k4a_playback_t,
        track_name: *const ::std::os::raw::c_char,
        data_block_handle: *mut k4a_playback_data_block_t,
    ) -> k4a_stream_result_t;
}
extern "C" {
    #[doc = " Get the device timestamp of a data block in microseconds."]
    #[doc = ""]
    #[doc = " \\param data_block_handle"]
    #[doc = " Handle obtained by k4a_playback_get_next_data_block() or k4a_playback_get_previous_data_block()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns the device timestamp of the data block. If the \\p data_block_handle is invalid this function will return 0."]
    #[doc = " It is also possible for 0 to be a valid timestamp originating from when a device was first powered on."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_data_block_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_data_block_get_device_timestamp_usec(
        data_block_handle: k4a_playback_data_block_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Get the buffer size of a data block."]
    #[doc = ""]
    #[doc = " \\param data_block_handle"]
    #[doc = " Handle obtained by k4a_playback_get_next_data_block() or k4a_playback_get_previous_data_block()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns the buffer size of the data block, or 0 if the data block is invalid."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_data_block_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_data_block_get_buffer_size(
        data_block_handle: k4a_playback_data_block_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Get the buffer of a data block."]
    #[doc = ""]
    #[doc = " \\param data_block_handle"]
    #[doc = " Handle obtained by k4a_playback_get_next_data_block() or k4a_playback_get_previous_data_block()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this buffer to access the data written to a custom recording track."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns a pointer to the data block buffer, or NULL if the data block is invalid."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_data_block_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_data_block_get_buffer(
        data_block_handle: k4a_playback_data_block_t,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Release a data block handle."]
    #[doc = ""]
    #[doc = " \\param data_block_handle"]
    #[doc = " Handle obtained by k4a_playback_get_next_data_block() or k4a_playback_get_previous_data_block()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Release the memory of a data block. The caller must not access the object after it is released."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_data_block_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_data_block_release(data_block_handle: k4a_playback_data_block_t);
}
extern "C" {
    #[doc = " Seek to a specific timestamp within a recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\param offset_usec"]
    #[doc = " The timestamp offset to seek to, relative to \\p origin"]
    #[doc = ""]
    #[doc = " \\param origin"]
    #[doc = " Specifies how the given timestamp should be interpreted. Seek can be done relative to the beginning or end of the"]
    #[doc = " recording, or using an absolute device timestamp."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_RESULT_SUCCEEDED if the seek operation was successful, or ::K4A_RESULT_FAILED if an error occured. The current"]
    #[doc = " seek position is left unchanged if a failure is returned."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first device timestamp in a recording is usually non-zero. The recording file starts at the device timestamp"]
    #[doc = " defined by start_timestamp_offset_usec, which is accessible via k4a_playback_get_record_configuration()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_next_capture() after k4a_playback_seek_timestamp() will return the first capture"]
    #[doc = " containing an image timestamp greater than or equal to the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_previous_capture() after k4a_playback_seek_timestamp() will return the first"]
    #[doc = " capture with all image timestamps less than the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_next_imu_sample() after k4a_playback_seek_timestamp() will return the first imu"]
    #[doc = " sample with a timestamp greter than or equal to the seek time."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The first call to k4a_playback_get_previous_imu_sample() after k4a_playback_seek_timestamp() will return the first"]
    #[doc = " imu sample with a timestamp less than the seek time."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_seek_timestamp(
        playback_handle: k4a_playback_t,
        offset_usec: i64,
        origin: k4a_playback_seek_origin_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Returns the length of the recording in microseconds."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The recording length, calculated as the difference between the first and last timestamp in the file."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The recording length may be longer than an individual track if, for example, the IMU continues to run after the last"]
    #[doc = " color image is recorded."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_recording_length_usec(playback_handle: k4a_playback_t) -> u64;
}
extern "C" {
    #[doc = " Gets the last timestamp in a recording, relative to the start of the recording."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " The file timestamp of the last capture image or IMU sample in microseconds."]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function returns a file timestamp, not an absolute device timestamp, meaning it is relative to the start of the"]
    #[doc = " recording. This function is equivalent to the length of the recording."]
    #[doc = ""]
    #[doc = " \\deprecated"]
    #[doc = " Deprecated starting in 1.2.0. Please use k4a_playback_get_recording_length_usec()."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_get_last_timestamp_usec(playback_handle: k4a_playback_t) -> u64;
}
extern "C" {
    #[doc = " Closes a recording playback handle."]
    #[doc = ""]
    #[doc = " \\param playback_handle"]
    #[doc = " Handle obtained by k4a_playback_open()."]
    #[doc = ""]
    #[doc = " \\headerfile playback.h <k4arecord/playback.h>"]
    #[doc = ""]
    #[doc = " \\relates k4a_playback_t"]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">playback.h (include k4arecord/playback.h)</requirement>"]
    #[doc = "   <requirement name=\"Library\">k4arecord.lib</requirement>"]
    #[doc = "   <requirement name=\"DLL\">k4arecord.dll</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub fn k4a_playback_close(playback_handle: k4a_playback_t);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
